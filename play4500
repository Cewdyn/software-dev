#!/usr/bin/env python

# CS4500 Assignment 8
# Nate Bessa, Dan Brown, Kyle Oestreich, Tyler Rosini

import os
import sys
import getopt
import time
import json
import pipes
import tempfile
import copy

from subprocess import PIPE, Popen

# ----------------------------------------------------
#  Game Messages:
#	A. Referee to Player Messages
#		1. Invalid Board Setup
#		2. Invalid Board Move <moveErrorType>
#		3. <position 1> <position 2> <player> <movetype>
#		4. F <position>
# 		5. <winningPlayer> Victory
#	B. Player to Referee Messages
#		1. (<position> <position>)
#		2. (initial board setup...)
# ----------------------------------------------------

# expected command line arg format:
#		./play4500 --go <n> --time/move <t>
# sample format:
#		./play4500 --go 1 --time/move 1.2ms		


##############################################################
#### Global Constants #######################################
##############################################################

ALGORITHM_DEPTH = 2






##############################################################
#### Class Definitons #######################################
##############################################################

	
class Board:
	def __init__(self, nodes):
		self.nodes = nodes
		self.history = []
		self.age = 0


	def __str__(self):
		results = "Board( Nodes:["
		
		for key, node in self.nodes.iteritems():
			results = results + str(node) + " "
		
		results = results + "])"
		
		return results	


	def getNodes(self):
		return self.nodes

	def setNodes(self, nodes):
		self.nodes = nodes

	def getHistory(self):
		return self.history

	def setHistory(self, history):
		self.history = history

	def getAge(self):
		return self.age

	def setAge(self, age):
		self.age = age

	def getNode(self, nodeId):
		return self.nodes[nodeId]

	def setNodePiece(self, nodeId, piece):



		oldNode = self.nodes[nodeId]

		oldPiece = oldNode.getPiece()

		self.history.append({"nodeId":nodeId, "piece":oldPiece})

		oldNode.setPiece(piece)

		self.age = self.age + 1	



	def undoLastChange(self):

		lastChange = self.history[len(self.history) - 1]

		nodeId = lastChange["nodeId"]

		oldPiece = lastChange["piece"]

		self.getNode(nodeId).setPiece(oldPiece)

		self.age = self.age - 1


	def revertToAge(self, age):



		while age < self.age:
			self.undoLastChange()


	def makeMove(self, frm, to, typ):

		if typ == "move" or typ == "win":
			fromNode = self.getNode(frm)
			self.setNodePiece(frm, None)
			self.setNodePiece(to, fromNode.getPiece())
		elif typ == "tie":
			self.setNodePiece(frm, None)
			self.setNodePiece(to,None)
		elif typ == "loss":
			self.setNodePiece(frm, None)


	def makeCopy(self):

		newSelf = Board({})

		newThingDict = {}

		for key, val in self.nodes.iteritems():
			newThingDict[key] = val.makeCopy()

		newSelf.setNodes(newThingDict)

		return newSelf





class Node:
	def __init__(self, id, type, piece, connections):
		self.id = id
		self.type = type
		self.piece = piece
		self.connections = connections
	  
	def getId(self):
		return self.id
		
	def setId(self, id):
		self.id = id
		
	def getType(self):
		return self.type
		
	def setType(self, type):
		self.type = type
		
	def getPiece(self):
		return self.piece
	
	def setPiece(self, piece):
		self.piece = piece
	
	def getConnections(self):
		return self.connections  
		
	def setConnections(self, connections):
		self.connections = connections

	def makeCopy(self):
		newSelf = Node(self.id, self.type, self.piece, self.connections)

		return newSelf

	
	def __repr__(self):
		results = "Node(Id:" + str(self.id) + " Type:" + self.type + " Piece:" + str(self.piece) #+ " Connections:["
		
		#for conn in self.connections:
		#	results += str(conn) + " "
		
		results = results + ")"
		
		return results		
	
	def __str__(self):
		results = "Node(Id:" + str(self.id) + " Type:" + self.type + " Piece:" + str(self.piece) #+ " Connections:["
		
		#for conn in self.connections:
		#	results = results + str(conn) + " "
		
		results = results + ")"
		
		return results	
		

class FPiece:
	def __init__(self, id, type):
		self.id = id
		self.type = type
		
	def getId(self):
		return self.id
		
	def getType(self):
		return self.type
	
	def setType(self, type):
		self.type = type


	def __str__(self):
		return "FPiece(Id:" + str(self.id) + " Type:" + self.type + ") "		

# Class which represents an Enemy Piece		
class EPiece:
	def __init__(self, id):
		self.id = id
		
	def getId(self):
		return self.id
		
	def __str__(self):
		return "EPiece(Id: " + str(self.id) + ") "
		
# class to represent a set of possible pieces belonging to rank
class rankSet:
	
	def __init__(self, rank, amount):
		self.rank = rank
		self.amount = amount
		# at game start, any enemy piece ID could be of this rank
		self.possiblePieces = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
			11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]
		 
		# as the game is played, added enemy piece IDs here as we unmask them
		self.definitePieces = []
		
	def getRank(self):
		return self.rank

	def setRank(self, rank):
		self.rank = rank
	
	# how many pieces of this rank does the enemy start with?
	def getAmount(self):
		return self.amount

	def setAmount(self, amount):
		self.amount = amount
		
	def getPossiblePieces(self):
		return self.possiblePieces

	def setPossiblePieces(self, possiblePieces):
		self.possiblePieces = possiblePieces
		
	def getDefinitePieces(self):
		return self.definitePieces
	
	def setDefinitePieces(self, definitePieces):
		self.definitePieces = definitePieces

	def removePossiblePiece(self, piece):
		self.possiblePieces.remove(piece.getId())
	
	# by declaring a piece of this rank, we must remove its possibility 
	# of being of any other rank
	def addDefinitePiece(self, piece):
		self.definitePieces.append(piece.getId())
		removePossibilities(piece, self.getRank()) 
	
	# TO-DO: need to call this function at some point
	# if we've found all the enemy piece IDs with this rank, purge 
	# possiblePieces
	def purgePossible(self):
		if len(self.definitePieces) == self.amount:
			self.possiblePieces = self.definitePieces

	def makeCopy(self):
		copy = rankSet(self.rank, self.amount)
		copy.setPossiblePieces(list(self.possiblePieces))
		copy.setDefinitePieces(list(self.definitePieces))

		return copy


class Connection:
	def __init__(self, connectedId, typ):
		self.connectedId = connectedId
		self.typ = typ
		
	def getConnectedId(self):
		return self.connectedId
		
	def setConnectedId(self, connectedId):
		self.connectedId = connectedId
		
	def getType(self):
		return self.typ
		
	def setType(self, typ):
		self.type = typ

	def __str__(self):
		return "Connection(To:" + str(self.connectedId) + \
			" Type:" + self.typ + ") "



## Denotes a possible move outcome. Includes an outcome rankset, board and
## the probability of this outcome.
class Outcome:
	def __init__(self, rankSet, probability, hqExplored, moveFrom, moveTo):

		self.rankSet = rankSet
		self.probability = probability
		self.hqExplored = hqExplored
		self.moveFrom = moveFrom
		self.moveTo = moveTo


	def getRankSet(self):
		return self.rankSet

	def setRankSet(self, rankSet):
		self.rankSet = rankSet

	def getProbability(self):
		return self.probability

	def setProbability(self, probability):
		self.probability = probability

	def getHQExplored(self):
		return self.hqExplored

	def setHQExplored(self, hqExplored):
		self.hqExplored = hqExplored

	def getMoveFrom(self):
		return self.moveFrom
		
	def setMoveFrom(self, moveFrom):
		self.moveFrom = moveFrom

	def getMoveTo(self):
		return self.moveTo
		
	def setMoveTo(self, moveTo):
		self.moveTo = moveTo

## Contains the all the outcomes and probabilities of a battle. Used
# by the algorithm to predict board scores from battle movements

class Battle:

	def getWinOutcome(self):
		return self.winOutcome

	def setWinOutcome(self, winOutcome):
		self.winOutcome = winOutcome

	def getWinProb(self):
		return self.winProb

	def setWinProb(self, winProb):
		self.winProb = winProb

	def getTieOutcome(self):
		return self.tieOutcome

	def setTieOutcome(self, tieOutcome):
		self.tieOutcome = tieOutcome

	def getTieProb(self):
		return self.tieProb

	def setTieProb(self, tieProb):
		self.tieProb = tieProb

	def getLossOutcome(self):
		return self.lossOutcome

	def setLossOutcome(self, lossOutcome):
		self.lossOutcome = lossOutcome

	def getLossProb(self):
		return self.lossProb

	def setLossProb(self, lossProb):
		self.lossProb = lossProb


##############################################################
#### Global Variables #######################################
##############################################################

nodes = Board({})
ourPlayer = 0
lastMove = ""
firstHQExplored = False




##############################################################
#### Functions ##############################################
##############################################################

## Makes a copy of the either the given rankProbs or the given board
def makeCopy(thingDict):

	newThingDict = {}

	for key, val in thingDict.iteritems():
		newThingDict[key] = val.makeCopy()

	return newThingDict



## Finds the next best move, using minmax
def getNextMove():
	
	

	bestScore = -1000000000000000
	
	global firstHQExplored
	
	moves = getPossibleMoves(nodes, rankSets, True, firstHQExplored)

	board = nodes.makeCopy()

	board.setAge(0)

#	sys.stderr.write("Number of Possible moves: " + str(len(moves)) + "\n")

	for move in moves:
		if isinstance(move, Battle):
			if (move.getWinProb() > 0):
				winOutcome = move.getWinOutcome()
				board.makeMove(winOutcome.getMoveFrom(), winOutcome.getMoveTo(), "win")
				
#				sys.stderr.write("1. Calling MinMax \n")
				winScore = minmax(board, winOutcome.getRankSet(), winOutcome.getHQExplored(), ALGORITHM_DEPTH - 1, False, -1000000000, 1000000000)
				board.revertToAge(0)
			else:
				winScore = 0

			if (move.getTieProb() > 0):
				tieOutcome = move.getTieOutcome()
				board.makeMove(tieOutcome.getMoveFrom(), tieOutcome.getMoveTo(), "tie")
				
#				sys.stderr.write("2. Calling MinMax \n")
				tieScore = minmax(board, tieOutcome.getRankSet(), tieOutcome.getHQExplored(), ALGORITHM_DEPTH - 1, False, -1000000000, 1000000000)
				board.revertToAge(0)
			else:
				tieScore = 0

			if (move.getLossProb() > 0):
				lossOutcome = move.getLossOutcome()
				board.makeMove(lossOutcome.getMoveFrom(), lossOutcome.getMoveTo(), "loss")
				

#				sys.stderr.write("3. Calling MinMax \n")
				lossScore = minmax(board, lossOutcome.getRankSet(), lossOutcome.getHQExplored(), ALGORITHM_DEPTH - 1, False, -1000000000, 1000000000)
				board.revertToAge(0)
			else:
				lossScore = 0

			score = ((winScore * move.getWinProb()) + (tieScore * move.getTieProb()) + (lossScore * move.getLossProb()))
			tempMove = move.getWinOutcome()

		else:
			board.makeMove(move.getMoveFrom(), move.getMoveTo(), "move")
#			sys.stderr.write("4. Calling MinMax \n")
			score = minmax(board, rankSets, firstHQExplored, ALGORITHM_DEPTH - 1, False, -1000000000, 1000000000)
			board.revertToAge(0)
			tempMove = move


		sys.stderr.write("Score is: " + str(score) + "\n")	
		if bestScore < score:
			bestScore = score
			bestMove = tempMove
	
	sys.stderr.write("Top Score is: " + str(bestScore) + "\n")

	return "( " + tempMove.getMoveFrom() + " " + tempMove.getMoveTo() + " )" 

#Main minmax algorithm. This function will go to depth levels down a decision tree
# computing which move tree provides the best outcome
def minmax(board, rankProbs, hqExplored, depth, maxing, alpha, beta):

	if (depth == 0):
		sys.stderr.write("Returning due to depth\n")

	if (depth == 0 or isLeaf(board, hqExplored)):
		
		return scoreBoard(board, rankProbs, hqExplored)
		

	moves = getPossibleMoves(board, rankProbs, maxing, hqExplored)
	
	sys.stderr.write("Number of moves is: " + str(len(moves)) + "\n")

	for move in moves:
	
		startAge = board.getAge()
	
		if isinstance(move, Battle):
			if (move.getWinProb() > 0):
				winOutcome = move.getWinOutcome()
				board.makeMove(winOutcome.getMoveFrom(), winOutcome.getMoveTo(), "win")
				winScore = minmax(board, winOutcome.getRankSet(), winOutcome.getHQExplored(), depth - 1, not maxing, alpha, beta)
				board.revertToAge(startAge)

			else:
				winScore = 0

			if (move.getTieProb() > 0):
				tieOutcome = move.getTieOutcome()
				board.makeMove(tieOutcome.getMoveFrom(), tieOutcome.getMoveTo(), "tie")
				tieScore = minmax(board, tieOutcome.getRankSet(), tieOutcome.getHQExplored(), depth - 1, not maxing, alpha, beta)
				board.revertToAge(startAge)
			else:
				tieScore = 0

			if (move.getLossProb() > 0):
				lossOutcome = move.getLossOutcome()
				board.makeMove(lossOutcome.getMoveFrom(), lossOutcome.getMoveTo(), "loss")
				lossScore = minmax(board, lossOutcome.getRankSet(), lossOutcome.getHQExplored(), depth - 1, not maxing, alpha, beta)
				board.revertToAge(startAge)
			else:
				lossScore = 0


#			sys.stderr.write("Tie Probability is: " + str(move.getTieProb()) + "\n")
#			sys.stderr.write("Loss Probability is: " + str(move.getLossProb()) + "\n")

#			sys.stderr.write("Win Score is: " + str(winScore) + "\n")
#			sys.stderr.write("Tie Score is: " + str(tieScore) + "\n")
#			sys.stderr.write("Loss Score is: " + str(lossScore) + "\n")
			score = ((winScore * move.getWinProb()) + (tieScore * move.getTieProb()) + (lossScore * move.getLossProb()))
			
#			sys.stderr.write("Battle Score is: " + str(score) + "\n")
		else:
			board.makeMove(move.getMoveFrom(), move.getMoveTo(), "move")
			score = minmax(board, move.getRankSet(), move.getHQExplored(), depth - 1, not maxing, alpha, beta)
			board.revertToAge(startAge)

			

#		sys.stderr.write("MM Score is: " + str(score) + "\n")	

		if(not maxing):
			if (beta > score):
				
				beta = score
				
				if (alpha >= beta):
					break
	
		else:
			if (alpha < score):
				
				alpha = score
				
				if (alpha >= beta):
					break
			
#	sys.stderr.write("Maxing: " + str(maxing) + " Alpha: " + str(alpha) + " Beta: " + str(beta) + "\n")

	if (maxing):
		return alpha
	else:
		return beta

# Given a board's state, it will return true if there are no more moves left
# or if the game has finished.
def isLeaf(board, hqExplored):

	if hqExplored and isinstance(board.getNode("D12").getPiece(), FPiece):
#		sys.stderr.write("Returning 1\n")	
		return True
	elif isinstance(board.getNode("B1").getPiece(), EPiece):
#		sys.stderr.write("Returning 2\n")
		return True

	existsFriendly = False
	existsEnemy = False

	'''
		for key, node in board.getNodes().iteritems():
			if not existsFriendly and isinstance(node.getPiece(), FPiece):
				existsFriendly = True

			if not existsEnemy and isinstance(node.getPiece(), EPiece):
				existsEnemy = True

			if existsFriendly and existsEnemy:
				break

		if not existsFriendly or not existsEnemy:
			sys.stderr.write("Returning 3\n")
			return True

	'''
	return False

# Given a board state, it will return an array of all possible moves for
# either the AI or the enemy
def getPossibleMoves(board, rankProbs, isAI, hqExplored):

	moves = []



	

	for key, node in board.getNodes().iteritems():

		piece = node.getPiece()

		if piece is not None:
			
			if isAI and isinstance(piece, FPiece): 
				moves.extend(getPiecePossibleMoves(node, board, rankProbs, isAI, hqExplored))
			elif not isAI and isinstance(piece, EPiece):
				moves.extend(getPiecePossibleMoves(node, board, rankProbs, isAI, hqExplored))

	return moves


# Given an Piece, it will determine all the possible moves it can make,
# including all possible outcomes of the move, the probability of each and
# the updated rankset
def getPiecePossibleMoves(node, board, rankProbs, isAI, hqExplored):



	piece = node.getPiece()

	outcomes = []

	for connection in node.getConnections():

		shallowMoveToNode = board.getNode(connection.getConnectedId())
		shallowMoveToPiece = shallowMoveToNode.getPiece()

		if shallowMoveToNode.getType() == "camp" and shallowMoveToPiece is not None:
			continue
		elif isinstance(shallowMoveToPiece, FPiece) and isAI:
			continue
		elif isinstance(shallowMoveToPiece, EPiece) and not isAI:
			continue


		if shallowMoveToPiece is None:

			moveToNode = board.getNode(connection.getConnectedId())
			moveFromNode = board.getNode(node.getId())

		
			if not hqExplored and moveToNode.getId() == "B12" and isAI:
				hqExplored = True

			outcomes.append(Outcome(rankProbs, 1, hqExplored, moveFromNode.getId(), moveToNode.getId()))

		elif shallowMoveToPiece is not None:

			moveToNode = board.getNode(connection.getConnectedId())
			moveFromNode = board.getNode(node.getId())

			outcomes.append(getPossibleOutcomes(moveFromNode, moveToNode, rankProbs, isAI, hqExplored))

	return outcomes


## Given a board, a node to move from and a node to move to, finds the possible
# outcomes
def getPossibleOutcomes(moveFromNode, moveToNode, rankProbs, isAI, hqExplored):

	battle = Battle()

	if isAI:
		winProb = probOfWinning(moveFromNode.getPiece(), moveToNode.getPiece(), rankProbs)
		tieProb = probOfTieing(moveFromNode.getPiece(), moveToNode.getPiece(), rankProbs)
		lossProb = probOfLosing(moveFromNode.getPiece(), moveToNode.getPiece(), rankProbs)
	else:
		winProb = probOfLosing(moveToNode.getPiece(), moveFromNode.getPiece(), rankProbs)
		tieProb = probOfTieing(moveToNode.getPiece(), moveFromNode.getPiece(), rankProbs)
		lossProb = probOfWinning(moveToNode.getPiece(), moveFromNode.getPiece(), rankProbs)
		


	if winProb > 0:
 
		
		winProbs = makeCopy(rankProbs)
		

		##HANDLE UPDATING RANKSETS
		if isAI:
			updateProbabilities(moveToNode.getPiece(), moveFromNode.getPiece(), "win", ourPlayer, winProbs)
		else:
			if ourPlayer == 1:
				player = 2
			else:
				player = 1

			updateProbabilities(moveFromNode.getPiece(), moveToNode.getPiece(), "win", player, winProbs)

		if (not hqExplored) and (moveToNode.getId() == "B12"):
			hqEplored = True

		battle.setWinProb(winProb)
		battle.setWinOutcome(Outcome(winProbs, winProb, hqExplored, moveFromNode.getId(), moveToNode.getId()))

	else:
		battle.setWinProb(0)


	if tieProb > 0:

		tieProbs = makeCopy(rankProbs)

		##HANDLE UPDATING RANKSETS
		if isAI:
			updateProbabilities(moveToNode.getPiece(), moveFromNode.getPiece(), "tie", ourPlayer, tieProbs)
		else:
			if ourPlayer == 1:
				player = 2
			else:
				player = 1

			updateProbabilities(moveFromNode.getPiece(), moveToNode.getPiece(), "tie", player, tieProbs)


		battle.setTieProb(tieProb)
		
		battle.setTieOutcome(Outcome(tieProbs, tieProb, hqExplored, moveFromNode.getId(), moveToNode.getId()))
	else:
		battle.setTieProb(0)

	if lossProb > 0:

		loseProbs = makeCopy(rankProbs)

		

		##HANDLE UPDATING RANKSETS
		if isAI:
			updateProbabilities(moveToNode.getPiece(), moveFromNode.getPiece(), "loss", ourPlayer, loseProbs)
		else:
			if ourPlayer == 1:
				player = 2
			else:
				player = 1

			updateProbabilities(moveFromNode.getPiece(), moveToNode.getPiece(), "loss", player, loseProbs)



		battle.setLossProb(lossProb)
		
		battle.setLossOutcome(Outcome(loseProbs, lossProb, hqExplored, moveFromNode.getId(), moveToNode.getId()))

	else:
		battle.setLossProb(0)

	return battle


# Analyzes a board configuration and returns a point value in terms of
# the strength of the AI's position
def scoreBoard(board, rankProbs, hqExplored):
	
	score = 0

	for key, node in board.getNodes().iteritems():
		piece = node.getPiece()

		if isinstance(piece, FPiece):
			score = score + (100 * getTypeValue(piece.getType()))
		elif isinstance(piece, EPiece):
			score = score - 1000 #getEPieceScore(piece, rankProbs)

	dist = getDistanceToFlag(board, False, hqExplored)
	#enemyDist = getDistanceToFlag(board, True, False)

	score = score - (dist * 100)
	#score = score + (enemyDist * 450)
	return score


##	Returns a point value number for a piece's type
def getTypeValue(type):


	if type == "B":
		return 6
	elif type == "L":
		return 3
	elif type == "1":
		return 3
	elif type == "F":
		return 10
	else:
		return int(type)


# Gets the heuristic score for an EPiece. This is difficult because it has to
# take into account the probabilities of the piece's type.
def getEPieceScore(piece, rankProbs):

	score = 0

	for i in xrange(2, 9):
		score = score + (probOfType(piece, str(i), rankProbs) * (i * 100))

	score = score + (probOfType(piece, "1", rankProbs) * 200)
	score = score + (probOfType(piece, "L", rankProbs) * 300)
	score = score + (probOfType(piece, "B", rankProbs) * 400)

	return -1 * score


## Finds the distance from the closest Friendly peice on the board to the 
# an enemy's unexplored castle
def getDistanceToFlag(board, isEnemy, hqExplored):
	
	if isEnemy:
		goal = "A1"
	elif (not hqExplored):
		goal = "A12"
	else: 
		goal = "E12"

	result = 1000

	for val, node in board.getNodes().iteritems():
		if not isEnemy and isinstance(node.getPiece(), FPiece):
#			sys.stderr.write("Running distance formula\n")
			dist = getDistance(node.getId(), goal)
			if dist < result:
				result = dist
		elif isEnemy and isinstance(node.getPiece(), EPiece):
			dist = getDistance(node.getId(), goal)
			if dist < result:
				result = dist

	#sys.stderr.write("Result is: " + str(result) + " for isEnemy: " + str(isEnemy) + " and hqExplored: " + str(hqExplored) + "\n")
	return result

## Given two positions on the board, a start and an end position, it calculates
#   the number of steps required to get to that position
def getDistance(start, end):
	#sys.stderr.write("Start is: " + str(start) + " End is: " + str(end) + "\n")
	if len(start) > 2:
		sy = float(start[-2:])
	else:
		sy = float(start[1])


	sx = getIntVal(start[0])
	
	
	#sys.stderr.write("sy: " + str(sy) + "\n")
	#sys.stderr.write("sx: " + str(sx) + "\n")

	if len(end) > 2:
		ey = float(end[-2:])
	else:
		ey = float(end[1])

	ex = getIntVal(end[0])


	#sys.stderr.write("ey: " + str(ey) + "\n")
	#sys.stderr.write("ex: " + str(ex) + "\n")

	return (((ex - sx)**2) + ((ey - sy)**2))**(0.5)




## Translates Letter into integer x value
def getIntVal(xStr):

	if xStr == "A":
		return 1.0
	elif xStr == "B":
		return 2.0
	elif xStr == "C":
		return 3.0
	elif xStr == "D":
		return 4.0
	else:
		return 5.0


# syntax checking function
def syntaxChecker(arguments):
	
	# valid number of arguments?
	if len(arguments) != 4:
		print >> sys.stderr, "Invalid amount of arguments."
		sys.exit(1)
	
	# is first argument --go
	if arguments[0] != '--go':
		print >> sys.stderr, "The 1st argument should be --go."
		sys.exit(1)
	
	# is second argument 1 or 2
	if arguments[1] != '1' and arguments[1] != '2':
		print >> sys.stderr, "The 2nd argument should be 1 or 2 for the player #."
		sys.exit(1)
	
	# is third argument --time/move
	if arguments[2] != '--time/move':
		print >> sys.stderr, "The 3rd argument should be --time/move."
		sys.exit(1)
	
	# check for any char in fourth argument that is not '.', a #, 'm', or 's'
	periodCount = 0
	mCount = 0
	sCount = 0
	for char in arguments[3]:
		if char == '.':
			periodCount += 1
		elif char == 'm':
			mCount += 1
		elif char == 's':
			sCount += 1
		elif char.isdigit():
			pass
		else:
			print >> sys.stderr, "Unexpected character in the time argument."
			sys.exit(1)
	if periodCount > 1 or mCount > 1 or sCount == 0 or sCount > 1:
		print >> sys.stderr, "The fourth argument is not properly formatted."
		sys.exit(1)

# parse the time argument, convert to seconds
def getTimeLimit(timeString):
	
	# split the string into the time portion and the 'ms' or 's' string
	if 'm' in timeString:
		timeSplit = timeString.find('m')
		time = float(timeString[0:timeSplit])
		time = time / 1000
	elif 's' in timeString:
		timeSplit = timeString.find('s')
		time = float(timeString[0:timeSplit])
	
	# get just the time portion
	return time
	
# take a JSON initial configuration and convert to the specification's CFG
def jsonToCFG():

	# open our own initial configuration
	initConfig = open("initConfig.json")
	test = json.load(initConfig)
	initConfig.close()
	
	# convert to CFG format specified by the professor
	output = "( "
	for piece in test:
		 output += "( " + piece["position"] + " " + piece["piece"] + " ) "
	output += ")"
	
	return output
	
# updates the board using information parsed from the referree message
def updateBoard(movingFrom, movingTo, movingPlayer, moveType):
	
	# NATE'S DEBUGGING STUFF ----------------------------------------------------
	
	# sys.stderr.write("--- BOARD: ourPlayer: " + str(ourPlayer) + ", movingPlayer: " + str(movingPlayer) + "\n")
	
	# END NATE'S DEBUGGING STUFF ------------------------------------------------
	
	global nodes
	global rankSets
	
	# if the ref returns 1 and we need to update our side of the board
	if int(movingPlayer) == ourPlayer:
		# updating the board for a move type "move". Just take the piece in the
		# movingFrom position and put it in the movingTo position. Then empty the
		#	old position
		if moveType == "move":
			
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			setNode = nodes.getNode(movingTo)
			setNode.setPiece(fPiece)
			
			# TO-DO: call update in case a piece has moved more than one spot & must
			# be an engineer
			
		elif moveType == "win":
			# removes our piece from old location by setting the movingFrom to None	
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# deletes Enemy piece by setting our piece on the new space
			setNode = nodes.getNode(movingTo)
			ePiece = setNode.getPiece()
			setNode.setPiece(fPiece)
				
			# update enemy probabilities
			updateProbabilities(ePiece, fPiece, moveType, int(movingPlayer), rankSets)
			
		elif moveType == "loss":
			# set the movingFrom to empty, which should delete our piece.
			# not changing the enemy's piece as it stays in the same spot.
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# get the enemy piece attacked
			setNode = nodes.getNode(movingTo)
			ePiece = setNode.getPiece()

			# update enemy probabilities
			updateProbabilities(ePiece, fPiece, moveType, int(movingPlayer), rankSets)
			
		elif moveType == "tie":
			# set the movingFrom to empty, which should delete the piece
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# set the movingTo to empty, which deletes enemy piece
			setNode = nodes.getNode(movingTo)
			ePiece = setNode.getPiece()
			setNode.setPiece(None)
					
			# update enemy probabilities
			updateProbabilities(ePiece, fPiece, moveType, int(movingPlayer), rankSets)
			
	else:
	
		if moveType == "move":
			
			delNode = nodes.getNode(movingFrom)
			piece = delNode.getPiece()
			delNode.setPiece(None)
			
			setNode = nodes.getNode(movingTo)
			setNode.setPiece(piece)
			
			# TO-DO: call update in case a piece has moved more than one spot & must
			# be an engineer
			
		if moveType == "win":
			# set the movingTo to empty, which should delete the enemy piece 
			# from the previous position
			delNode = nodes.getNode(movingFrom)
			ePiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# place the enemy piece on the movingTo node, deleting our piece	
			setNode = nodes.getNode(movingTo)
			fPiece = setNode.getPiece()
			setNode.setPiece(ePiece)
			
			# update enemy probabilities
			updateProbabilities(ePiece, fPiece, moveType, int(movingPlayer), rankSets)
			
		if moveType == "loss":
			# set the movingFrom to empty, which deletes the enemy piece
			delNode = nodes.getNode(movingFrom)
			ePiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# get our player's piece
			setNode = nodes.getNode(movingTo)
			fPiece = setNode.getPiece()

			# update enemy probabilities
			updateProbabilities(ePiece, fPiece, moveType, int(movingPlayer), rankSets)
			
		elif moveType == "tie":
			# set the movingTo to empty, which deletes the enemy piece
			delNode = nodes.getNode(movingFrom)
			ePiece = delNode.getPiece()
			delNode.setPiece(None)
					
			# set the movingFrom to empty, which deletes our piece
			delNode = nodes.getNode(movingTo)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)

			# update enemy probabilities
			updateProbabilities(ePiece, fPiece, moveType, int(movingPlayer), rankSets)

#  places piece in the board
def injectPiece(piece, id):
	
	global nodes
	
	piecePos = piece["position"]
	pieceType = piece["piece"]
	
	node = nodes.getNode(piecePos)
	node.setPiece(FPiece(id, pieceType))

# function to debug nate's classes
def createRankSets():
	
	global rank1
	global rank2
	global rank3
	global rank4
	global rank5
	global rank6
	global rank7
	global rank8
	global rank9
	global rankL
	global rankB
	global rankF
	global rankSets
	
	rank1 = rankSet("1", 3)
	rank2 = rankSet("2", 3)
	rank3 = rankSet("3", 3)
	rank4 = rankSet("4", 2)
	rank5 = rankSet("5", 2)
	rank6 = rankSet("6", 2)
	rank7 = rankSet("7", 2)
	rank8 = rankSet("8", 1)
	rank9 = rankSet("9", 1)
	rankL = rankSet("L", 3)
	rankB = rankSet("B", 2)
	rankF = rankSet("F", 1)
	
	rankSets = {"1" : rank1,
							"2" : rank2,
							"3" : rank3,
							"4" : rank4,
							"5" : rank5,
							"6" : rank6,
							"7" : rank7,
							"8" : rank8,
							"9" : rank9,
							"L" : rankL,
							"B" : rankB,
							"F" : rankF}
							

# Given a piece and a type, calculates the probability that the piece is
# that type
def probOfType(piece, typ, rankProbs):

	typeDenom = 0

	for key, set in rankProbs.iteritems():
		if key == typ:
			if piece.getId() in set.getPossiblePieces():
				typeNumer = set.getAmount()
				typeDenom = typeDenom + set.getAmount()
			else:
				return 0;
		else:
			if piece.getId() in set.getPossiblePieces():
				typeDenom = typeDenom + set.getAmount()


	return float(typeNumer / typeDenom)


# determine the probability of one of our pieces beating one of the enemy's.
# takes instances of EPiece and FPiece class
def probOfWinning(playerPiece, enemyPiece, rankProbs):

	enemyPieceID = enemyPiece.getId()
	playerPieceID = playerPiece.getId()
	playerPieceType = playerPiece.getType()
	
	# convert rank types to integers for easier looping (INDEXED AT 0)
	if playerPieceType == "B":
		playerPieceTypeInt = 9
	elif playerPieceType == "F":
		playerPieceTypeInt = 10
	elif playerPieceType == "L":
		playerPieceTypeInt = 11
	else:
		playerPieceTypeInt = int(playerPieceType) - 1 
	
	# TO-DO: getDefinitePieces is not currently in use
	# check if this enemy piece's rank has already been discovered
 	# for key, set in iter(sorted(rankSets.iteritems())):
 	# 	if enemyPieceID in set.getDefinitePieces():
 	# 		# TO-DO: needs to check if the rank is lower than ours
 	# 		return 1
 	
	# probability of losing
 	probabilityAgainstWeighted = 0
 	
 	# probability of winning
 	probabilityForWeighted = 0
 	
 	# currently unused, but may be useful for future probability metrics
	probabilityForCount = 0
 	probabilityAgainstCount = 0

 	i = 0
 	for key, set in iter(sorted(rankProbs.iteritems())):
 		# ranks we will win over
 		if i < playerPieceTypeInt:
	 		if enemyPieceID in set.getPossiblePieces():
	 			rankProbability = float(set.getAmount()) / len(set.getPossiblePieces())
	 			probabilityForWeighted += rankProbability
	 			probabilityForCount += 1
	 	# ranks we will lose or tie to 
	 	else:
	 		if enemyPieceID in set.getPossiblePieces():
	 			# don't consider flags in the list of pieces that could defeat us
	 			if i != 10:
	 				rankProbability = float(set.getAmount()) / len(set.getPossiblePieces())
	 				probabilityAgainstWeighted += rankProbability
	 				probabilityAgainstCount += 1
	 	i += 1
	
	# get the total amount of weight
	totalProbabilityWeight = probabilityForWeighted + probabilityAgainstWeighted

	# the prob of winning is the favorable probability divided by total weight 
	finalProbability = probabilityForWeighted / totalProbabilityWeight
	
 	return finalProbability

# get the probability of losing
def probOfLosing(playerPiece, enemyPiece, rankProbs):
	
	return 1 - probOfWinning(playerPiece, enemyPiece, rankProbs)
	
# get the probability of tieing
def probOfTieing(playerPiece, enemyPiece, rankProbs):

	enemyPieceID = enemyPiece.getId()
	playerPieceID = playerPiece.getId()
	playerPieceType = playerPiece.getType()
	
	# convert rank types to integers for easier looping (INDEXED AT 0)
	if playerPieceType == "B":
		playerPieceTypeInt = 9
	elif playerPieceType == "F":
		playerPieceTypeInt = 10
	elif playerPieceType == "L":
		playerPieceTypeInt = 11
	else:
		playerPieceTypeInt = int(playerPieceType) - 1 
		
	probabilityTieWeighted = 0
	probabilityNotTieWeighted = 0
	
	i = 0
	for key, set in iter(sorted(rankProbs.iteritems())):
		# an engineer wont tie a landmine
		if playerPieceTypeInt == 1 and i == 11:
			rankProbability = float(set.getAmount()) / len(set.getPossiblePieces())
			probabilityNotTieWeighted += rankProbability
		# ranks that can tie are the same rank, a bomb or landmine 
		elif i == playerPieceTypeInt or i == 9 or i == 11:
			rankProbability = float(set.getAmount()) / len(set.getPossiblePieces())
			probabilityTieWeighted += rankProbability
		else:
			rankProbability = float(set.getAmount()) / len(set.getPossiblePieces())
			probabilityNotTieWeighted += rankProbability
	
	# get the total probability weight
	totalProbabilityWeight = probabilityTieWeighted + probabilityNotTieWeighted
	
	# the prob of tieing is the prob of a tie divided by total weight
	finalProbability = probabilityTieWeighted / totalProbabilityWeight
	
	return finalProbability
			
# update probabilities TO-DO
def updateProbabilities(enemyPiece, playerPiece, moveOutcome, movingPlayer, rankProbs):

	# NATE'S DEBUGGING STUFF ----------------------------------------------------
	
	# sys.stderr.write("--- PROBS: ourPlayer: " + str(ourPlayer) + ", movingPlayer: " + str(movingPlayer) + "\n")
	
	# END NATE'S DEBUGGING STUFF ------------------------------------------------

	# TO-DO: KNOW IF AN ENGINEER BECAUSE MOVES MORE THAN ONE BOARD SPACE
	

	enemyPieceID = enemyPiece.getId()
	playerPieceID = playerPiece.getId()
	playerPieceType = playerPiece.getType()
	
	# convert moveOutcomes to our player's perspective
	if movingPlayer != ourPlayer:
		if moveOutcome == "win":
			moveOutcome = "loss"
		elif moveOutcome == "loss":
			moveOutcome = "win"
	
	# convert rank types to integers for easier looping
	# note: INDEXED AT 0
	if playerPieceType == "B":
		playerPieceTypeInt = 9
	elif playerPieceType == "F":
		playerPieceTypeInt = 10
	elif playerPieceType == "L":
		playerPieceTypeInt = 11
	else:
		playerPieceTypeInt = int(playerPieceType) - 1 
	
	if moveOutcome == "tie":
		# if tie, enemy piece is either of same rank or a bomb or landmine
		for key, set in rankProbs.iteritems():
			if key != "L" and key != "B" and key != playerPieceType and enemyPiece in set.getPossiblePieces():
		 		set.removePossiblePiece(enemyPiece)
	elif moveOutcome == "win":
		# remove enemy from all ranks higher than our rank and remove L/B/F
		i = 0
		for key, set in iter(sorted(rankProbs.iteritems())):
			if i >= playerPieceTypeInt:
				# if our piece is an engineer, do not remove possibility enemy was an L
				if playerPieceTypeInt == 1 and i == 11:
					pass
				elif enemyPiece in set.getPossiblePieces():
					set.removePossiblePiece(enemyPiece)
			i += 1
	elif moveOutcome == "loss":
		# remove enemy from all ranks below our rank and remove L/B/F possibility
		i = 0
		for key, set in iter(sorted(rankProbs.iteritems())):
			if i <= playerPieceTypeInt and enemyPiece in set.getPossiblePieces():
				set.removePossiblePiece(enemyPiece)
			elif i > 8 and enemyPiece in set.getPossiblePieces():
				set.removePossiblePiece(enemyPiece)
			i += 1
				
	# TO-DO: needs to check and use addDefinitePiece
	
	# NATE'S DEBUGGING STUFF ----------------------------------------------------
	
	#for key, set in iter(sorted(rankProbs.iteritems())):
	#	sys.stderr.write("--- P: " + str(ourPlayer) + ", MP: " + str(movingPlayer) + \
	#		str(set.getPossiblePieces()) + "\n")
	
	# END NATE'S DEBUGGING STUFF ------------------------------------------------
			
# remove enemy piece IDs from all rank set's possiblePiece if its 
# discovered elsewhere
def removePossibilities(enemyPiece, knownRank):

	enemyPieceID = enemyPiece.getId()
	
	for key, set in iter(sorted(rankSets.iteritems())):
		if key != knownRank:
			set.removePossiblePiece(enemyPieceID)


# put the enemy pieces on the board
def placeEnemyPieces():
	
	positions = ["A7","A8","A9","A10","A11","A12","B7","B9","B11","B12","C7",
	"C8","C10","C11","C12","D7","D9","D11","D12","E7","E8","E9","E10",
	"E11","E12"]
	
	for i, pos in enumerate(positions):
		nodes.getNode(pos).setPiece(EPiece(i))

# get the locations of all our pieces
def getPiecePositions():
	positions = []
	
	for key, node in nodes.iteritems():
		# check if a node contains a friendly piece
		if node.getPiece():
			if isinstance(node.getPiece(),FPiece): 
				#if (ourPlayer == 1):
				#	sys.stderr.write("Piece is: " + str(node.getPiece()) +
				#	 " at: " + key + " adding to piece list.\n")
				positions.append(key)
			
	return positions


###############################################################################
# TYLER'S OLD MOVE FUNCTIONS : TO BE DELETED ----------------------------------

# calculate our next move
def calculateMove():
	global lastMove
	bestMove = ""
	piecePositions = getPiecePositions()
	for pos in piecePositions:
		# for now pick the best move(based on moving forward, later change to min-max algo) 
		move = getBestMove(pos)
		if(move):
			if(bestMove == "") or moveValue(move[1:3],pos) > moveValue(bestMove[1:3],bestMove[4:6]):
				bestMove = move
	if(bestMove != ""):					
		lastMove = bestMove[1:3]
		return bestMove	


# grabs the best move for a given piece
# (for now just grabs the first valid move)		
def getBestMove(pos):
	bestMove = ""
	node = nodes.getNode(pos)
	
	piece = node.getPiece()
	if not piece.getType() == "L" and not piece.getType() == "F":
		for connection in node.getConnections():
			move = connection.getConnectedId()
			
			if isMoveValid(move,pos):
				if bestMove == "" or moveValue(move,pos) > moveValue(bestMove,pos):
					bestMove = move
	if(bestMove != ""):					
		return "(" + pos + " " + bestMove + ")"

# END TYLER'S OLD MOVE FUNCTIONS ----------------------------------------------
###############################################################################


# determine if a move is valid (for now means we arn't moving onto 
# a space occupied by our own piece), and its a move forward, and we aren't attacking a camp.
def isMoveValid(move, currentPos):
	if nodes.getNode(move).getPiece():
		# check if piece is friendly or enemy
		if isinstance(nodes.getNode(move).getPiece(),FPiece):
			return False
		#check that we aren't trying to attack piece on a camp
		elif isinstance(nodes.getNode(move).getPiece(),EPiece) and (nodes.getNode(move).getType() == "camp"):
			return False
		else:
			return True
	
	else:
		return True
	
# Determines move value based on moving forward and if we are attacking an enemy piece.	
def moveValue(move, pos):
	global lastMove
	value = 1
	if int(move[1]) > int(pos[1]):
		value += int(pos[1])
	else:
		value = 0
	if nodes.getNode(move).getPiece():
		value += 1
	if move == lastMove:
		value = 0
	return value
		        
def main():
	
	global nodes
	global ourPlayer
	global rank1
	global rank2
	global rank3
	global rank4
	global rank5
	global rank6
	global rank7
	global rank8
	global rank9
	global rankL
	global rankB
	global rankF
	global rankSets
	
	# parse command line options
	args = sys.argv[1:]
	
	# check for invalid syntax, pass only the arguments (not the file name)
	syntaxChecker(args)
	
	# convert the time argument to a float of seconds
	timeLimit = getTimeLimit(args[3])
	
	# create a CFG of the initial board configuration
	initialConfig = jsonToCFG()
	
	# which player are we
	ourPlayer = int(args[1])

	nodeD = {}

	#A nodes	
	nodeD["A1"] = (Node("A1","standard", None, [Connection("B1", "standard"),
																							Connection("A2", "standard")]))
	nodeD["A2"] = (Node("A2","standard", None, [Connection("A1", "standard"),
																							Connection("B2", "rail"),
																							Connection("B3","standard"),
																							Connection("A3","rail")]))
	nodeD["A3"] = (Node("A3","standard", None, [Connection("A2", "rail"),
																							Connection("B3", "standard"),
																							Connection("A4","rail")]))
	nodeD["A4"] = (Node("A4","standard", None, [Connection("A3", "rail"),
																							Connection("B3", "standard"),
																							Connection("B4","standard"),
																							Connection("B5","standard"),
																							Connection("A5","rail")]))
	nodeD["A5"] = (Node("A5","standard", None, [Connection("A4", "rail"),
																							Connection("B5", "standard"),
																							Connection("A6","rail")]))
	nodeD["A6"] = (Node("A6","standard", None, [Connection("A5", "rail"),
																							Connection("B5", "standard"),
																							Connection("B6","rail"),
																							Connection("A7","rail")]))
	nodeD["A7"] = (Node("A7","standard", None, [Connection("A6", "rail"),
																							Connection("B7", "rail"),
																							Connection("B8","standard"),
																							Connection("A8","rail")]))
	nodeD["A8"] = (Node("A8","standard", None, [Connection("A7", "rail"),
																							Connection("B8", "standard"),
																							Connection("A9","rail")]))
	nodeD["A9"] = (Node("A9","standard", None, [Connection("A8", "rail"),
																							Connection("B8", "standard"),
																							Connection("B9","standard"),
																							Connection("B10","standard"),
																							Connection("A10","rail")]))
	nodeD["A10"] = (Node("A10","standard", None, [Connection("A9", "rail"),
																								Connection("B10", "standard"),
																								Connection("A11","rail")]))
	nodeD["A11"] = (Node("A11","standard", None, [Connection("A10", "rail"),
																								Connection("B10","standard"),
																								Connection("B11","rail"),
																								Connection("A12","standard")]))
	nodeD["A12"] = (Node("A12","standard", None, [Connection("A11", "standard"),
																								Connection("B12","standard")]))
			
	#B nodes
	nodeD["B1"] = (Node("B1","HQ", None, [Connection("C1", "standard"),
																				Connection("B2", "standard"),
																				Connection("A1", "standard")]))
	nodeD["B2"] = (Node("B2","standard", None, [Connection("B1", "standard"),
																							Connection("C2", "rail"),
																							Connection("B3","standard"),
																							Connection("A2","rail")]))
	nodeD["B3"] = (Node("B3","camp", None, [Connection("B2", "standard"),
																					Connection("C2", "standard"),
																					Connection("C3","standard"),
																					Connection("C4", "standard"),
																					Connection("B4", "standard"),
																					Connection("A4","standard"),
																					Connection("A3","standard"),
																					Connection("A2","standard")]))
	nodeD["B4"] = (Node("B4","standard", None, [Connection("B3", "standard"),
																							Connection("C4", "standard"),
																							Connection("B5","standard"),
																							Connection("A4","standard")]))
	nodeD["B5"] = (Node("B5","camp", None, [Connection("B4", "standard"),
																					Connection("C4", "standard"),
																					Connection("C5","standard"),
																					Connection("C6", "standard"),
																					Connection("B6", "standard"),
																					Connection("A6","standard"),
																					Connection("A5", "standard"),
																					Connection("A4","standard")]))
	nodeD["B6"] = (Node("B6","standard", None, [Connection("B5", "rail"),
																							Connection("C6", "rail"),
																							Connection("A6","rail")]))
	nodeD["B7"] = (Node("B7","standard", None, [Connection("C7", "rail"),
																							Connection("B8", "standard"),
																							Connection("A7","rail")]))
	nodeD["B8"] = (Node("B8","camp", None, [Connection("B7", "standard"),
																					Connection("C7", "standard"),
																					Connection("C8","standard"),
																					Connection("C9", "standard"),
																					Connection("B9", "standard"),
																					Connection("A9","standard"),
																					Connection("A8", "standard"),
																					Connection("A7", "standard")]))
	nodeD["B9"] = (Node("B9","standard", None, [Connection("B8", "standard"),
																							Connection("C9", "standard"),
																							Connection("B10","standard"),
																							Connection("A9","standard")]))
	nodeD["B10"] = (Node("B10","camp", None, [Connection("B9", "standard"),
																						Connection("C9", "standard"),
																						Connection("C10","standard"),
																						Connection("C11", "standard"),
																						Connection("B11", "standard"),
																						Connection("A11","standard"),
																						Connection("A10", "standard"),
																						Connection("A9", "standard")]))
	nodeD["B11"] = (Node("B11","standard", None, [Connection("B10", "standard"),
																								Connection("C11","rail"),
																								Connection("B12","standard"),
																								Connection("A11","rail")]))
	nodeD["B12"] = (Node("B12","HQ", None, [Connection("B11", "standard"),
																					Connection("C12","standard"),
																					Connection("A12","standard")]))
		
	#C nodes
	nodeD["C1"] = (Node("C1","standard", None, [Connection("B1", "standard"),
																							Connection("C2", "standard"),
																							Connection("D1", "standard")]))
	nodeD["C2"] = (Node("C2","standard", None, [Connection("C1", "standard"),
																							Connection("D2", "rail"),
																							Connection("D3","standard"),
																							Connection("C3","standard"),
																							Connection("B3","standard"),
																							Connection("B2","rail")]))
	nodeD["C3"] = (Node("C3","standard", None, [Connection("C2", "standard"),
																							Connection("D3", "standard"),
																							Connection("C4","standard"),
																							Connection("B3", "standard")]))
	nodeD["C4"] = (Node("C4","camp", None, [Connection("C3", "standard"),
																					Connection("D3", "standard"),
																					Connection("D4","standard"),
																					Connection("D5","standard"),
																					Connection("C5", "standard"),
																					Connection("B5", "standard"),
																					Connection("B4","standard"),
																					Connection("B3","standard")]))
	nodeD["C5"] = (Node("C5","standard", None, [Connection("C4", "standard"),
																							Connection("D5", "standard"),
																							Connection("C6","standard"),
																							Connection("B5", "standard")]))
	nodeD["C6"] = (Node("C6","standard", None, [Connection("C5", "standard"),
																							Connection("D5", "standard"),
																							Connection("D6","rail"),
																							Connection("C7", "rail"),
																							Connection("B6", "rail"),
																							Connection("B5","standard")]))
	nodeD["C7"] = (Node("C7","standard", None, [Connection("C6", "rail"),
																							Connection("D7", "rail"),
																							Connection("D8","standard"),
																							Connection("C8","standard"),
																							Connection("B8","standard"),
																							Connection("B7","standard")]))
	nodeD["C8"] = (Node("C8","standard", None, [Connection("C7", "standard"),
																							Connection("D8", "standard"),
																							Connection("C9","standard"),
																							Connection("C8", "standard")]))
	nodeD["C9"] = (Node("C9","camp", None, [Connection("C8", "standard"),
																					Connection("D8", "standard"),
																					Connection("D9","standard"),
																					Connection("D10","standard"),
																					Connection("C10", "standard"),
																					Connection("B10", "standard"),
																					Connection("B9","standard"),
																					Connection("B8","standard")]))
	nodeD["C10"] = (Node("C10","standard", None, [Connection("C9", "standard"),
																							Connection("D10", "standard"),
																							Connection("C11","standard"),
																							Connection("B10", "standard")]))
	nodeD["C11"] = (Node("C11","standard", None, [Connection("C10", "standard"),
																								Connection("D10","standard"),
																								Connection("D11","rail"),
																								Connection("C12","standard"),
																								Connection("B11","rail"),
																								Connection("B10","standard")]))
	nodeD["C12"] = (Node("C12","standard", None, [Connection("C11", "standard"),
																								Connection("D12","standard"),
																								Connection("B12","standard")]))

	#D nodes
	nodeD["D1"] = (Node("D1","HQ", None, [Connection("E1", "standard"),
																				Connection("D2", "standard"),
																				Connection("C1", "standard")]))
	nodeD["D2"] = (Node("D2","standard", None, [Connection("D1", "standard"),
																							Connection("E2", "rail"),
																							Connection("D3","standard"),
																							Connection("C2","rail")]))
	nodeD["D3"] = (Node("D3","camp", None, [Connection("D2", "standard"),
																					Connection("E2", "standard"),
																					Connection("E3","standard"),
																					Connection("E4", "standard"),
																					Connection("D4", "standard"),
																					Connection("C4","standard"),
																					Connection("C3","standard"),
																					Connection("C2","standard")]))
	nodeD["D4"] = (Node("D4","standard", None, [Connection("D3", "standard"),
																							Connection("E4", "standard"),
																							Connection("D5","standard"),
																							Connection("C4","standard")]))
	nodeD["D5"] = (Node("D5","camp", None, [Connection("D4", "standard"),
																					Connection("E4", "standard"),
																					Connection("E5","standard"),
																					Connection("E6", "standard"),
																					Connection("D6", "standard"),
																					Connection("C6","standard"),
																					Connection("C5", "standard"),
																					Connection("C4","standard")]))
	nodeD["D6"] = (Node("D6","standard", None, [Connection("D5", "rail"),
																							Connection("E6", "rail"),
																							Connection("C6","rail")]))
	nodeD["D7"] = (Node("D7","standard", None, [Connection("E7", "rail"),
																							Connection("D8", "standard"),
																							Connection("C7","rail")]))
	nodeD["D8"] = (Node("D8","camp", None, [Connection("D7", "standard"),
																					Connection("E7", "standard"),
																					Connection("E8","standard"),
																					Connection("E9", "standard"),
																					Connection("D9", "standard"),
																					Connection("C9","standard"),
																					Connection("C8", "standard"),
																					Connection("C7", "standard")]))
	nodeD["D9"] = (Node("D9","standard", None, [Connection("D8", "standard"),
																							Connection("E9", "standard"),
																							Connection("D10","standard"),
																							Connection("C9","standard")]))
	nodeD["D10"] = (Node("D10","camp", None, [Connection("D9", "standard"),
																						Connection("E9", "standard"),
																						Connection("E10","standard"),
																						Connection("E11", "standard"),
																						Connection("D11", "standard"),
																						Connection("C11","standard"),
																						Connection("C10", "standard"),
																						Connection("C9", "standard")]))
	nodeD["D11"] = (Node("D11","standard", None, [Connection("D10", "standard"),
																								Connection("E11","rail"),
																								Connection("D12","standard"),
																								Connection("C11","rail")]))
	nodeD["D12"] = (Node("D12","HQ", None, [Connection("D11", "standard"),
																					Connection("E12","standard"),
																					Connection("C12","standard")]))

	#E nodes	
	nodeD["E1"] = (Node("E1","standard", None, [Connection("D1", "standard"),
																							Connection("E2", "standard")]))
	nodeD["E2"] = (Node("E2","standard", None, [Connection("E1", "standard"),
																							Connection("E3", "rail"),
																							Connection("D3","standard"),
																							Connection("D2","rail")]))
	nodeD["E3"] = (Node("E3","standard", None, [Connection("E2", "rail"),
																							Connection("D3", "standard"),
																							Connection("E4","rail")]))
	nodeD["E4"] = (Node("E4","standard", None, [Connection("E3", "rail"),
																							Connection("E5", "rail"),
																							Connection("D5","standard"),
																							Connection("D4","standard"),
																							Connection("D3","standard")]))
	nodeD["E5"] = (Node("E5","standard", None, [Connection("E4", "rail"),
																							Connection("D5", "standard"),
																							Connection("E6","rail")]))
	nodeD["E6"] = (Node("E6","standard", None, [Connection("E5", "rail"),
																							Connection("D5", "standard"),
																							Connection("D6","rail"),
																							Connection("E7","rail")]))
	nodeD["E7"] = (Node("E7","standard", None, [Connection("E6", "rail"),
																							Connection("D7", "rail"),
																							Connection("D8","standard"),
																							Connection("E8","rail")]))
	nodeD["E8"] = (Node("E8","standard", None, [Connection("E7", "rail"),
																							Connection("D8", "standard"),
																							Connection("E9","rail")]))
	nodeD["E9"] = (Node("E9","standard", None, [Connection("E8", "rail"),
																							Connection("D8", "standard"),
																							Connection("D9","standard"),
																							Connection("D10","standard"),
																							Connection("E10","rail")]))
	nodeD["E10"] = (Node("E10","standard", None, [Connection("E9", "rail"),
																								Connection("D10", "standard"),
																								Connection("E11","rail")]))
	nodeD["E11"] = (Node("E11","standard", None, [Connection("E10", "rail"),
																								Connection("D10","standard"),
																								Connection("D11","rail"),
																								Connection("E12","standard")]))
	nodeD["E12"] = (Node("E12","standard", None, [Connection("E11", "standard"),
																								Connection("D12","standard")]))
	
	nodes.setNodes(nodeD)

	# open our json that has our initial configuration
	initConfig = open("initConfig.json")
	initConfigArray = json.load(initConfig)

	# place the pieces from the json configuration into our nodes
	i = 0
	for piece in initConfigArray:
		injectPiece(piece, i)
		i += 1

	initConfig.close()
	
	# initialize our probability metrics and rank sets
	createRankSets()

	# set up the enemy pieces on the board
	placeEnemyPieces();

	# send the referee our initial configuration
	sys.stdout.write(initialConfig)
	sys.stdout.flush()
		
	# if it is our turn first, send the referee our first move
	if ourPlayer == 1:
		sys.stdout.write("( A6 A7 )")
		sys.stdout.flush()
	
	while(True):
	
		# get the input from the ref
		message = raw_input()

		# start capturing the time duration of our move (not needed for prototype)
		# startTime = time.time() 
	
		if (message == "Invalid Board Setup"):
			sys.stderr.write("Board was not correctly set up. Exiting game.\n")
			sys.exit(0)
		
		# match just the first 18 characters which are always the same
		elif (message[:18] == "Invalid Board Move"):
			sys.stderr.write("We sent an invalid move. Exiting game.\n")
			sys.exit(0)
			
		elif ("Victory" in message):
			if ("1" in message):
				sys.stderr.write("Player 1 is the victor. Exiting game.\n")
				sys.exit(0)
			elif ("2" in message):
				sys.stderr.write("Player 2 is the victor. Exiting game.\n")
				sys.exit(0)
			else:
				sys.stderr.write("There was no victor. Exiting game.\n")
				sys.exit(0)
		
		elif (message[0] == "F"):
			# a field marshall has been captured and the flag is revealed
			# not needed for the prototype
			pass
		
		else:
			
			# make sure the referee's message is properly formatted
			if (message.count(' ') != 3):
				sys.stderr.write("Error: The referee provided an invalid message.\n")
				sys.exit(0)
			
			# parse the referee's input
			messageArgs = message.split(' ')
			movingFrom = messageArgs[0]
			movingTo = messageArgs[1]
			movingPlayer = messageArgs[2]
			moveType = messageArgs[3]
			
			# update our board (currently ignoring opponent's pieces and railroads)
			updateBoard(movingFrom, movingTo, movingPlayer, moveType)
				
			# we don't want to send our move, if the referee is simply reporting 
			# what we have done.
			if (ourPlayer == int(movingPlayer)):
				sys.stdout.flush()
				continue
			
			# NATE'S DEBUGGING ------------------------------------------------------
			
			# sys.exit(0)
			
			# END NATE'S DEBUGGING --------------------------------------------------
			
			# select the next move
			nextMove = getNextMove() # USE'S DAN'S HIGHLY ADVANCED ALGO
			# nextMove = calculateMove() # USE'S TYLER'S NEANDERTHAL ALGO
			
			# send the ref the move
			sys.stdout.write(nextMove)
			
			# check to make sure we haven't gone past our time limit 
			# (not needed for prototype)
			# timeLeft = timeLimit - (time.time() - startTime)
			# if (timeLeft <= 0):
			#	print "Error: We ran out of time to complete our move. Exiting game."
			#	sys.exit(0)

		sys.stdout.flush()
		
if __name__ == "__main__":
    main()
