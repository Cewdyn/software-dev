#!/usr/bin/env python

# CS4500 Assignment 10
# Nate Bessa, Dan Brown, Kyle Oestreich, Tyler Rosini

import os
import sys
import getopt
import time
import json
import pipes
import tempfile
import copy

from subprocess import PIPE, Popen

# ----------------------------------------------------
# Game Messages:
#	A. Referee to Player Messages
#		1. Invalid Board Setup
#		2. Invalid Board Move <moveErrorType>
#		3. <position 1> <position 2> <player> <movetype>
#		4. F <position>
# 		5. <winningPlayer> Victory
#	B. Player to Referee Messages
#		1. (<position> <position>)
#		2. (initial board setup...)
# ----------------------------------------------------

ALGORITHM_DEPTH = 2
TOTAL_BOARD_PIECES = 50

class Board:

	def __init__(self, nodes):
		self.nodes = nodes
		self.history = []
		self.age = 0

	def __str__(self):
		results = "Board( Nodes:["
		
		for key, node in self.nodes.iteritems():
			results = results + str(node) + " "
		
		results = results + "])"
		
		return results	

	def getNodes(self):
		return self.nodes

	def setNodes(self, nodes):
		self.nodes = nodes

	def getHistory(self):
		return self.history

	def setHistory(self, history):
		self.history = history

	def getAge(self):
		return self.age

	def setAge(self, age):
		self.age = age

	def getNode(self, nodeId):
		return self.nodes[nodeId]

	def setNodePiece(self, nodeId, piece):

		oldNode = self.getNode(nodeId)

		oldPiece = oldNode.getPiece()
		self.history.append({"nodeId":nodeId, "piece":oldPiece})

		oldNode.setPiece(piece)

		self.age = self.age + 1	

	def undoLastChange(self):

		lastChange = self.history.pop()

		nodeId = lastChange["nodeId"]

		oldPiece = lastChange["piece"]

		self.getNode(nodeId).setPiece(oldPiece)

		self.age = self.age - 1

	def revertToAge(self, age):

		while age < self.age:
			self.undoLastChange()

	def makeMove(self, frm, to, typ):

		if typ == "move" or typ == "win":
			fromNode = self.getNode(frm)
			self.setNodePiece(to, fromNode.getPiece())
			self.setNodePiece(frm, None)
		elif typ == "tie":
			self.setNodePiece(frm, None)
			self.setNodePiece(to, None)
		elif typ == "loss":
			self.setNodePiece(frm, None)

	def makeCopy(self):

		newSelf = Board({})

		newThingDict = {}

		for key, val in self.nodes.iteritems():
			newThingDict[key] = val.makeCopy()

		newSelf.setNodes(newThingDict)

		return newSelf

	def __str__(self):

		return "Board( Age: " + str(self.age) + " History: " + str(self.history) 
		+ " Nodes: " + str(self.nodes) + " )\n"

class Node:
	def __init__(self, ID, typ, piece, connections):
		self.id = ID
		self.typ = typ
		self.piece = piece
		self.connections = connections
	  
	def getId(self):
		return self.id
		
	def setId(self, ID):
		self.id = ID
		
	def getType(self):
		return self.typ
		
	def setType(self, typ):
		self.typ = typ
		
	def getPiece(self):
		return self.piece
	
	def setPiece(self, piece):
		self.piece = piece
	
	def getConnections(self):
		return self.connections  
		
	def setConnections(self, connections):
		self.connections = connections

	def makeCopy(self):
		newSelf = Node(self.id, self.typ, self.piece, self.connections)

		return newSelf
	
	def __repr__(self):
		results = "Node(Id:" + str(self.id) + " Type:" + self.typ 
		+ " Piece:" + str(self.piece) #+ " Connections:["
		
		results = results + ")"
		
		return results		
	
	def __str__(self):
		results = "Node(Id:" + str(self.id) + " Type:" + self.typ 
		+ " Piece:" + str(self.piece) #+ " Connections:["
				
		results = results + ")"
		
		return results	
		
# represents the player's piece
class FPiece:
	def __init__(self, ID, typ):
		self.id = ID
		self.typ = typ
		
	def getId(self):
		return self.id
		
	def getType(self):
		return self.typ
	
	def setType(self, typ):
		self.typ = typ

	def __str__(self):
		return "FPiece(Id:" + str(self.id) + " Type:" + str(self.typ) + ") "		

# class which represents an Enemy Piece		
class EPiece:
	def __init__(self, ID):
		self.ID = ID
		
	def getId(self):
		return self.ID
		
	def __str__(self):
		return "EPiece(Id: " + str(self.ID) + ") "
		
# class to represent a set of possible pieces belonging to rank
class rankSet:
	
	def __init__(self, rank, amount):
		self.rank = rank
		self.amount = amount
		# at game start, any enemy piece ID could be of this rank
		self.possiblePieces = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
			11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]
		 
		# as the game is played, added enemy piece IDs here as we unmask them
		self.definitePieces = []
		
	def getRank(self):
		return self.rank

	def setRank(self, rank):
		self.rank = rank
	
	# how many pieces of this rank does the enemy start with?
	def getAmount(self):
		return self.amount

	def setAmount(self, amount):
		self.amount = amount
		
	def getPossiblePieces(self):
		return self.possiblePieces

	def setPossiblePieces(self, possiblePieces):
		self.possiblePieces = possiblePieces
		
	def getDefinitePieces(self):
		return self.definitePieces
	
	def setDefinitePieces(self, definitePieces):
		self.definitePieces = definitePieces

	def removePossiblePiece(self, piece):
		self.possiblePieces.remove(piece.getId())
		
	# if we've found all the enemy piece IDs with this rank, purge 
	# possiblePieces
	def purgePossible(self):
		if len(self.definitePieces) == self.amount:
			self.possiblePieces = self.definitePieces

	def makeCopy(self):
		copy = rankSet(self.rank, self.amount)
		copy.setPossiblePieces(list(self.possiblePieces))
		copy.setDefinitePieces(list(self.definitePieces))

		return copy


class Connection:
	def __init__(self, connectedId, typ):
		self.connectedId = connectedId
		self.typ = typ
		
	def getConnectedId(self):
		return self.connectedId
		
	def setConnectedId(self, connectedId):
		self.connectedId = connectedId
		
	def getType(self):
		return self.typ
		
	def setType(self, typ):
		self.type = typ

	def __str__(self):
		return "Connection(To:" + str(self.connectedId) + \
			" Type:" + self.typ + ") "

# denotes a possible move outcome. Includes an outcome rankset, board and
# the probability of this outcome.
class Outcome:
	def __init__(self, rankSet, probability, hqExplored, moveFrom, moveTo):

		self.rankSet = rankSet
		self.probability = probability
		self.hqExplored = hqExplored
		self.moveFrom = moveFrom
		self.moveTo = moveTo


	def getRankSet(self):
		return self.rankSet

	def setRankSet(self, rankSet):
		self.rankSet = rankSet

	def getProbability(self):
		return self.probability

	def setProbability(self, probability):
		self.probability = probability

	def getHQExplored(self):
		return self.hqExplored

	def setHQExplored(self, hqExplored):
		self.hqExplored = hqExplored

	def getMoveFrom(self):
		return self.moveFrom
		
	def setMoveFrom(self, moveFrom):
		self.moveFrom = moveFrom

	def getMoveTo(self):
		return self.moveTo
		
	def setMoveTo(self, moveTo):
		self.moveTo = moveTo

# contains the all the outcomes and probabilities of a battle. Used
# by the algorithm to predict board scores from battle movements

class Battle:

	def getWinOutcome(self):
		return self.winOutcome

	def setWinOutcome(self, winOutcome):
		self.winOutcome = winOutcome

	def getWinProb(self):
		return self.winProb

	def setWinProb(self, winProb):
		self.winProb = winProb

	def getTieOutcome(self):
		return self.tieOutcome

	def setTieOutcome(self, tieOutcome):
		self.tieOutcome = tieOutcome

	def getTieProb(self):
		return self.tieProb

	def setTieProb(self, tieProb):
		self.tieProb = tieProb

	def getLossOutcome(self):
		return self.lossOutcome

	def setLossOutcome(self, lossOutcome):
		self.lossOutcome = lossOutcome

	def getLossProb(self):
		return self.lossProb

	def setLossProb(self, lossProb):
		self.lossProb = lossProb

nodes = Board({})
ourPlayer = 0
lastMove = ""
firstHQExplored = False

# makes a copy of the either the given rankProbs or the given board
def makeCopy(thingDict):

	newThingDict = {}

	for key, val in thingDict.iteritems():
		newThingDict[key] = val.makeCopy()

	return newThingDict

# finds the next best move, using minmax
def getNextMove():
	
	bestScore = -1000000000000000
	global firstHQExplored
	moves = getPossibleMoves(nodes, rankSets, True, firstHQExplored)
	board = nodes.makeCopy()
	board.setAge(0)

	for move in moves:
		if isinstance(move, Battle):
			if (move.getWinProb() > 0):
				winOutcome = move.getWinOutcome()
				board.makeMove(winOutcome.getMoveFrom(), winOutcome.getMoveTo(), "win")
				
				winScore = minmax(board, 
					winOutcome.getRankSet(), 
					winOutcome.getHQExplored(), 
					ALGORITHM_DEPTH - 1, 
					False, 
					-1000000000, 
					1000000000)
				board.revertToAge(0)

				tempMove = move.getWinOutcome()
			else:
				winScore = 0

			if (move.getTieProb() > 0):
				tieOutcome = move.getTieOutcome()
				board.makeMove(tieOutcome.getMoveFrom(), 
					tieOutcome.getMoveTo(), 
					"tie")
				
				tieScore = minmax(board, 
					tieOutcome.getRankSet(), 
					tieOutcome.getHQExplored(), 
					ALGORITHM_DEPTH - 1, 
					False, 
					-1000000000, 
					1000000000)
				board.revertToAge(0)

				tempMove = move.getTieOutcome()
			else:
				tieScore = 0

			if (move.getLossProb() > 0):
				lossOutcome = move.getLossOutcome()
				board.makeMove(lossOutcome.getMoveFrom(), 
					lossOutcome.getMoveTo(), 
					"loss")
				
				lossScore = minmax(board, 
					lossOutcome.getRankSet(), 
					lossOutcome.getHQExplored(), 
					ALGORITHM_DEPTH - 1, 
					False, 
					-1000000000, 
					1000000000)
				board.revertToAge(0)

				tempMove = move.getLossOutcome()
			else:
				lossScore = 0

			score = ((winScore * move.getWinProb()) 
			+ (tieScore * move.getTieProb()) 
			+ (lossScore * move.getLossProb()))

		else:
			board.makeMove(move.getMoveFrom(), move.getMoveTo(), "move")
			score = minmax(board, 
				rankSets, 
				firstHQExplored, 
				ALGORITHM_DEPTH - 1, 
				False, 
				-1000000000, 
				1000000000)
			board.revertToAge(0)
			tempMove = move

		if bestScore < score:
			bestScore = score
			bestMove = tempMove
	
	if len(moves) == 0:
		return "( )"

	return "( " + bestMove.getMoveFrom() + " " + bestMove.getMoveTo() + " )" 

# main minmax algorithm. This function will go to depth levels down a decision 
# tree computing which move tree provides the best outcome
def minmax(board, rankProbs, hqExplored, depth, maxing, alpha, beta):

	if (depth == 0 or isLeaf(board, hqExplored)):
		return scoreBoard(board, rankProbs, hqExplored)
	
	moves = getPossibleMoves(board, rankProbs, maxing, hqExplored)
	
	for move in moves:
	
		startAge = board.getAge()
		if isinstance(move, Battle):

			if (move.getWinProb() > 0):
				winOutcome = move.getWinOutcome()
				board.makeMove(winOutcome.getMoveFrom(), winOutcome.getMoveTo(), "win")
				winScore = minmax(board, 
					winOutcome.getRankSet(), 
					winOutcome.getHQExplored(), 
					depth - 1, 
					not maxing, 
					alpha, 
					beta)
				board.revertToAge(startAge)
			else:
				winScore = 0

			if (move.getTieProb() > 0):
				tieOutcome = move.getTieOutcome()
				board.makeMove(tieOutcome.getMoveFrom(), 
					tieOutcome.getMoveTo(), 
					"tie")
				tieScore = minmax(board, 
					tieOutcome.getRankSet(), 
					tieOutcome.getHQExplored(), 
					depth - 1, 
					not maxing, 
					alpha, 
					beta)
				board.revertToAge(startAge)
			else:
				tieScore = 0

			if (move.getLossProb() > 0):
				lossOutcome = move.getLossOutcome()
				board.makeMove(lossOutcome.getMoveFrom(), 
					lossOutcome.getMoveTo(), 
					"loss")
				lossScore = minmax(board, 
					lossOutcome.getRankSet(), 
					lossOutcome.getHQExplored(), 
					depth - 1, 
					not maxing, 
					alpha, 
					beta)
				board.revertToAge(startAge)
			else:
				lossScore = 0

			score = ((winScore * move.getWinProb()) + (tieScore * move.getTieProb()) 
			+ (lossScore * move.getLossProb()))
			
		else:
			board.makeMove(move.getMoveFrom(), move.getMoveTo(), "move")
			score = minmax(board, 
				move.getRankSet(), 
				move.getHQExplored(), 
				depth - 1, 
				not maxing, 
				alpha, 
				beta)
			board.revertToAge(startAge)

		if(not maxing):
			if (beta > score):
				beta = score
				
			if (alpha >= beta):
				break
	
		else:
			if (alpha < score):
				alpha = score
				
			if (alpha >= beta):
				break
			
	if (maxing):
		return alpha
	else:
		return beta

# given a board's state, it will return true if there are no more moves left
# or if the game has finished.
def isLeaf(board, hqExplored):

	if hqExplored and isinstance(board.getNode("D12").getPiece(), FPiece):
		return True
	elif isinstance(board.getNode("B1").getPiece(), EPiece):
		return True

	existsFriendly = False
	existsEnemy = False

	for key, node in board.getNodes().iteritems():
		if not existsFriendly and isinstance(node.getPiece(), FPiece):
			existsFriendly = True

		if not existsEnemy and isinstance(node.getPiece(), EPiece):
			existsEnemy = True

		if existsFriendly and existsEnemy:
			break

	if not existsFriendly or not existsEnemy:
		return True
	
	return False

# given a board state, it will return an array of all possible moves for
# either the AI or the enemy
def getPossibleMoves(board, rankProbs, isAI, hqExplored):

	moves = []
	pieceCount = 0

	for key, node in board.getNodes().iteritems():

		piece = node.getPiece()

		if piece is not None:
			pieceCount = pieceCount + 1
			if isAI and isinstance(piece, FPiece) and not piece.getType() == "L": 
				moves.extend(getPiecePossibleMoves(node, 
					board, 
					rankProbs, 
					isAI, 
					hqExplored))
			elif not isAI and isinstance(piece, EPiece):
				moves.extend(getPiecePossibleMoves(node, 
					board, 
					rankProbs, 
					isAI, 
					hqExplored))

	return moves


# given an Piece, it will determine all the possible moves it can make,
# including all possible outcomes of the move, the probability of each and
# the updated rankset
def getPiecePossibleMoves(node, board, rankProbs, isAI, hqExplored):

	piece = node.getPiece()
	outcomes = []

	for connection in node.getConnections():
		moveToNode = board.getNode(connection.getConnectedId())
		moveToPiece = moveToNode.getPiece()
		moveFromNode = board.getNode(node.getId())	

		if moveToNode.getType() == "camp" and moveToPiece is not None:
			continue
		elif isinstance(moveToPiece, FPiece) and isAI:
			continue
		elif isinstance(moveToPiece, EPiece) and not isAI:
			continue
		elif moveFromNode.getId() == "B1" or moveFromNode.getId() == "D1":
			continue
		elif moveFromNode.getId() == "B12" or moveFromNode.getId() == "D12":
			continue

		if moveToPiece is None:
			if not hqExplored and moveToNode.getId() == "B12" and isAI:
				hqExplored = True
			outcomes.append(Outcome(rankProbs, 
				1, 
				hqExplored, 
				moveFromNode.getId(), 
				moveToNode.getId()))
		else:
			if not hqExplored and moveToNode.getId() == "B12" and isAI:
				hqExplored = True
			outcomes.append(getPossibleOutcomes(moveFromNode, 
				moveToNode, 
				rankProbs, 
				isAI, 
				hqExplored))

	return outcomes


# given a board, a node to move from and a node to move to, finds the possible
# outcomes
def getPossibleOutcomes(moveFromNode, moveToNode, rankProbs, isAI, hqExplored):

	battle = Battle()

	if isAI:
		winProb = probOfWinning(moveFromNode.getPiece(), 
			moveToNode.getPiece(), 
			rankProbs)
		tieProb = probOfTieing(moveFromNode.getPiece(), 
			moveToNode.getPiece(), 
			rankProbs)
		lossProb = 1.0 - winProb
	else:
		winProb = probOfLosing(moveToNode.getPiece(), 
			moveFromNode.getPiece(), 
			rankProbs)
		tieProb = probOfTieing(moveToNode.getPiece(), 
			moveFromNode.getPiece(), 
			rankProbs)
		lossProb = 1.0 - winProb

	if winProb > 0:
		winProbs = makeCopy(rankProbs)
		
		# handle rankset updates
		if isAI:
			updateProbabilities(moveToNode.getPiece(), 
				moveFromNode.getPiece(), 
				"win", 
				ourPlayer, 
				winProbs)
		else:
			if ourPlayer == 1:
				player = 2
			else:
				player = 1

			updateProbabilities(moveFromNode.getPiece(), 
				moveToNode.getPiece(), 
				"win", 
				player, 
				winProbs)

		if (not hqExplored) and (moveToNode.getId() == "B12"):
			hqEplored = True

		battle.setWinProb(winProb)
		battle.setWinOutcome(Outcome(winProbs, 
			winProb, 
			hqExplored, 
			moveFromNode.getId(), 
			moveToNode.getId()))

	else:
		winProb = 0.2
		winProbs = makeCopy(rankProbs)
		
		# handle rankset updates
		if isAI:
			updateProbabilities(moveToNode.getPiece(), 
				moveFromNode.getPiece(), 
				"win", 
				ourPlayer, 
				winProbs)
		else:
			if ourPlayer == 1:
				player = 2
			else:
				player = 1

			updateProbabilities(moveFromNode.getPiece(), 
				moveToNode.getPiece(), 
				"win", 
				player, 
				winProbs)

		if (not hqExplored) and (moveToNode.getId() == "B12"):
			hqEplored = True

		battle.setWinProb(winProb)
		battle.setWinOutcome(Outcome(winProbs, 
			winProb, 
			hqExplored, 
			moveFromNode.getId(), 
			moveToNode.getId()))

	if tieProb > 0:
		tieProbs = makeCopy(rankProbs)
		# handle rankset updates
		if isAI:
			updateProbabilities(moveToNode.getPiece(), 
				moveFromNode.getPiece(), 
				"tie", 
				ourPlayer, 
				tieProbs)
		else:
			if ourPlayer == 1:
				player = 2
			else:
				player = 1

			updateProbabilities(moveFromNode.getPiece(), 
				moveToNode.getPiece(), 
				"tie", 
				player, 
				tieProbs)
				
		battle.setTieProb(tieProb)
		battle.setTieOutcome(Outcome(tieProbs, 
			tieProb, 
			hqExplored, 
			moveFromNode.getId(), 
			moveToNode.getId()))
			
	else:
		battle.setTieProb(0)

	if lossProb > 0:
		loseProbs = makeCopy(rankProbs)

		# handle rankset updates
		if isAI:
			updateProbabilities(moveToNode.getPiece(), 
				moveFromNode.getPiece(), 
				"loss", 
				ourPlayer, 
				loseProbs)
		else:
			if ourPlayer == 1:
				player = 2
			else:
				player = 1

			updateProbabilities(moveFromNode.getPiece(), 
				moveToNode.getPiece(), 
				"loss", 
				player, 
				loseProbs)

		battle.setLossProb(lossProb)
		battle.setLossOutcome(Outcome(loseProbs, 
			lossProb, 
			hqExplored, 
			moveFromNode.getId(), 
			moveToNode.getId()))

	else:
		battle.setLossProb(0)

	return battle

# analyzes a board configuration and returns a point value in terms of
# the strength of the AI's position
def scoreBoard(board, rankProbs, hqExplored):
	
	score = 0
	
	for key, node in board.getNodes().iteritems():
		piece = node.getPiece()

		if isinstance(piece, FPiece):
			score = score + (100 * getTypeValue(piece.getType()))
		elif isinstance(piece, EPiece):
			score = score - 900 #getEPieceScore(piece, rankProbs)
	
	dist = getDistanceToFlag(board, False, hqExplored)

	if hqExplored:
		goal = "D12"
	else:
		goal = "B12"

	if(isinstance(board.getNode(goal).getPiece(), FPiece)):
		score = score + 100000
	
	score = score - (dist * 1800)

	return score

# returns a point value number for a piece's type
def getTypeValue(typ):

	if typ == "B":
		return 6
	elif typ == "L":
		return 3
	elif typ == "1":
		return 3
	elif typ == "F":
		return 10
	else:
		return int(typ)

# gets the heuristic score for an EPiece. This is difficult because it has to
# take into account the probabilities of the piece's type.
def getEPieceScore(piece, rankProbs):

	score = 0

	for i in xrange(2, 9):
		score = score + (probOfType(piece, str(i), rankProbs) * (i * 100))

	score = score + (probOfType(piece, "1", rankProbs) * 200)
	score = score + (probOfType(piece, "L", rankProbs) * 300)
	score = score + (probOfType(piece, "B", rankProbs) * 400)

	return -1 * score


# finds the distance from the closest Friendly peice on the board to the 
# an enemy's unexplored castle
def getDistanceToFlag(board, isEnemy, hqExplored):
	
	if isEnemy:
		goal = "B1"
	elif (not hqExplored):
		goal = "B12"
	else: 
		goal = "D12"

	result = 0

	for val, node in board.getNodes().iteritems():
		if not isEnemy and isinstance(node.getPiece(), FPiece):
			dist = getDistance(node.getId(), goal)
			result = result + dist
		elif isEnemy and isinstance(node.getPiece(), EPiece):
			dist = getDistance(node.getId(), goal)
			result = result + dist
			
	return result

# given two positions on the board, a start and an end position, it calculates
#   the number of steps required to get to that position
def getDistance(start, end):

	if len(start) > 2:
		sy = float(start[-2:])
	else:
		sy = float(start[1])


	sx = getIntVal(start[0])

	if len(end) > 2:
		ey = float(end[-2:])
	else:
		ey = float(end[1])

	ex = getIntVal(end[0])

	return (((ex - sx)**2) + ((ey - sy)**2))**(0.5)

# translates letter into integer x value
def getIntVal(xStr):

	if xStr == "A":
		return 1.0
	elif xStr == "B":
		return 2.0
	elif xStr == "C":
		return 3.0
	elif xStr == "D":
		return 4.0
	else:
		return 5.0

# syntax checking function
def syntaxChecker(arguments):
	
	# valid number of arguments?
	if len(arguments) != 4:
		print >> sys.stderr, "Invalid amount of arguments."
		sys.exit(1)
	
	# is first argument --go
	if arguments[0] != '--go':
		print >> sys.stderr, "The 1st argument should be --go."
		sys.exit(1)
	
	# is second argument 1 or 2
	if arguments[1] != '1' and arguments[1] != '2':
		print >> sys.stderr, "The 2nd argument should be 1 or 2 for the player #."
		sys.exit(1)
	
	# is third argument --time/move
	if arguments[2] != '--time/move':
		print >> sys.stderr, "The 3rd argument should be --time/move."
		sys.exit(1)
	
	# check for any char in fourth argument that is not '.', a #, 'm', or 's'
	periodCount = 0
	mCount = 0
	sCount = 0
	for char in arguments[3]:
		if char == '.':
			periodCount += 1
		elif char == 'm':
			mCount += 1
		elif char == 's':
			sCount += 1
		elif char.isdigit():
			pass
		else:
			print >> sys.stderr, "Unexpected character in the time argument."
			sys.exit(1)
	if periodCount > 1 or mCount > 1 or sCount == 0 or sCount > 1:
		print >> sys.stderr, "The fourth argument is not properly formatted."
		sys.exit(1)

# parse the time argument, convert to seconds
def getTimeLimit(timeString):
	
	# split the string into the time portion and the 'ms' or 's' string
	if 'm' in timeString:
		timeSplit = timeString.find('m')
		time = float(timeString[0:timeSplit])
		time = time / 1000
	elif 's' in timeString:
		timeSplit = timeString.find('s')
		time = float(timeString[0:timeSplit])
	
	# get just the time portion
	return time
	
# take a JSON initial configuration and convert to the specification's CFG
def jsonToCFG():
	
	# open our own initial configuration
	initConfig = open("initConfig.json")
	test = json.load(initConfig)
	initConfig.close()
	
	# convert to CFG format specified by the professor
	output = "( "
	for piece in test:
		 output += "( " + piece["position"] + " " + piece["piece"] + " ) "
	output += ")"
	
	return output
	
# updates the board using information parsed from the referree message
def updateBoard(movingFrom, movingTo, movingPlayer, moveType):
	
	global nodes
	global rankSets
	global TOTAL_BOARD_PIECES
	global ALGORITHM_DEPTH
	
	# if the ref returns 1 and we need to update our side of the board
	if int(movingPlayer) == ourPlayer:
		# updating the board for a move type "move". Just take the piece in the
		# movingFrom position and put it in the movingTo position. Then empty the
		#	old position
		if moveType == "move":
			
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			setNode = nodes.getNode(movingTo)
			setNode.setPiece(fPiece)
			
		elif moveType == "win":
			# removes our piece from old location by setting the movingFrom to None	
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# deletes Enemy piece by setting our piece on the new space
			setNode = nodes.getNode(movingTo)
			ePiece = setNode.getPiece()
			setNode.setPiece(fPiece)
				
			# update enemy probabilities
			updateProbabilities(ePiece, 
				fPiece, 
				moveType, 
				int(movingPlayer), 
				rankSets)
			
			TOTAL_BOARD_PIECES -= 1
			
		elif moveType == "loss":
			# set the movingFrom to empty, which should delete our piece.
			# not changing the enemy's piece as it stays in the same spot.
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# get the enemy piece attacked
			setNode = nodes.getNode(movingTo)
			ePiece = setNode.getPiece()

			# update enemy probabilities
			updateProbabilities(ePiece, 
				fPiece, 
				moveType, 
				int(movingPlayer), 
				rankSets)
			
			TOTAL_BOARD_PIECES -= 1
			
		elif moveType == "tie":
			# set the movingFrom to empty, which should delete the piece
			delNode = nodes.getNode(movingFrom)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# set the movingTo to empty, which deletes enemy piece
			setNode = nodes.getNode(movingTo)
			ePiece = setNode.getPiece()
			setNode.setPiece(None)
					
			# update enemy probabilities
			updateProbabilities(ePiece, 
				fPiece, 
				moveType, 
				int(movingPlayer), 
				rankSets)
			
			TOTAL_BOARD_PIECES -= 2
			
	else:
	
		if moveType == "move":
			
			delNode = nodes.getNode(movingFrom)
			piece = delNode.getPiece()
			delNode.setPiece(None)
			
			setNode = nodes.getNode(movingTo)
			setNode.setPiece(piece)
						
		if moveType == "win":
			# set the movingTo to empty, which should delete the enemy piece 
			# from the previous position
			delNode = nodes.getNode(movingFrom)
			ePiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# place the enemy piece on the movingTo node, deleting our piece	
			setNode = nodes.getNode(movingTo)
			fPiece = setNode.getPiece()
			setNode.setPiece(ePiece)
			
			# update enemy probabilities
			updateProbabilities(ePiece, 
				fPiece, 
				moveType, 
				int(movingPlayer), 
				rankSets)
				
			TOTAL_BOARD_PIECES -= 1
			
		if moveType == "loss":
			# set the movingFrom to empty, which deletes the enemy piece
			delNode = nodes.getNode(movingFrom)
			ePiece = delNode.getPiece()
			delNode.setPiece(None)
			
			# get our player's piece
			setNode = nodes.getNode(movingTo)
			fPiece = setNode.getPiece()

			# update enemy probabilities
			updateProbabilities(ePiece, 
				fPiece, 
				moveType, 
				int(movingPlayer), 
				rankSets)
			
			TOTAL_BOARD_PIECES -= 1
			
		elif moveType == "tie":
			# set the movingTo to empty, which deletes the enemy piece
			delNode = nodes.getNode(movingFrom)
			ePiece = delNode.getPiece()
			delNode.setPiece(None)
					
			# set the movingFrom to empty, which deletes our piece
			delNode = nodes.getNode(movingTo)
			fPiece = delNode.getPiece()
			delNode.setPiece(None)

			# update enemy probabilities
			updateProbabilities(ePiece, 
				fPiece, 
				moveType, 
				int(movingPlayer), 
				rankSets)
			
			TOTAL_BOARD_PIECES -= 2

#  places piece in the board
def injectPiece(piece, ID):
	
	global nodes
	
	piecePos = piece["position"]
	pieceType = piece["piece"]
	
	node = nodes.getNode(piecePos)
	node.setPiece(FPiece(ID, pieceType))

# function to debug nate's classes
def createRankSets():
	
	global rank1
	global rank2
	global rank3
	global rank4
	global rank5
	global rank6
	global rank7
	global rank8
	global rank9
	global rankL
	global rankB
	global rankF
	global rankSets
	
	rank1 = rankSet("1", 3)
	rank2 = rankSet("2", 3)
	rank3 = rankSet("3", 3)
	rank4 = rankSet("4", 2)
	rank5 = rankSet("5", 2)
	rank6 = rankSet("6", 2)
	rank7 = rankSet("7", 2)
	rank8 = rankSet("8", 1)
	rank9 = rankSet("9", 1)
	rankL = rankSet("L", 3)
	rankB = rankSet("B", 2)
	rankF = rankSet("F", 1)
	
	rankSets = {"1" : rank1,
							"2" : rank2,
							"3" : rank3,
							"4" : rank4,
							"5" : rank5,
							"6" : rank6,
							"7" : rank7,
							"8" : rank8,
							"9" : rank9,
							"L" : rankL,
							"B" : rankB,
							"F" : rankF}
							

# Given a piece and a type, calculates the probability that the piece is
# that type
def probOfType(piece, typ, rankProbs):

	typeDenom = 0

	for key, set in rankProbs.iteritems():
		if key == typ:
			if piece.getId() in set.getPossiblePieces():
				typeNumer = set.getAmount()
				typeDenom = typeDenom + set.getAmount()
			else:
				return 0;
		else:
			if piece.getId() in set.getPossiblePieces():
				typeDenom = typeDenom + set.getAmount()

	return float(typeNumer / typeDenom)


# determine the probability of one of our pieces beating one of the enemy's.
# takes instances of EPiece and FPiece class
def probOfWinning(playerPiece, enemyPiece, rankProbs):

	enemyPieceID = enemyPiece.getId()
	playerPieceID = playerPiece.getId()
	playerPieceType = playerPiece.getType()
	
	# convert rank types to integers for easier looping (INDEXED AT 0)
	if playerPieceType == "B":
		playerPieceTypeInt = 9.0
	elif playerPieceType == "F":
		playerPieceTypeInt = 10.0
	elif playerPieceType == "L":
		playerPieceTypeInt = 11.0
	else:
		playerPieceTypeInt = float(playerPieceType) - 1.0
	 	
	# probability of losing
 	probabilityAgainstWeighted = 0.0
 	
 	# probability of winning
 	probabilityForWeighted = 0.0
 	
 	# currently unused, but may be useful for future probability metrics
	probabilityForCount = 0.0
 	probabilityAgainstCount = 0.0

 	i = 0.0
 	for key, set in iter(sorted(rankProbs.iteritems())):
 		# ranks we will win over
 		if i < playerPieceTypeInt:
	 		if enemyPieceID in set.getPossiblePieces():
	 			rankProbability = set.getAmount() / float(len(set.getPossiblePieces()))
	 			probabilityForWeighted += rankProbability
	 			probabilityForCount += 1.0
	 	# ranks we will lose or tie to 
	 	else:
	 		if enemyPieceID in set.getPossiblePieces():
	 			# don't consider flags in the list of pieces that could defeat us
	 			if i != 10.0:
	 				rankProbability = set.getAmount() / \
	 					float(len(set.getPossiblePieces()))
	 				probabilityAgainstWeighted += rankProbability
	 				probabilityAgainstCount += 1.0
	 	i += 1.0
	
	# get the total amount of weight
	totalProbabilityWeight = probabilityForWeighted + probabilityAgainstWeighted

	# the prob of winning is the favorable probability divided by total weight 
	finalProbability = probabilityForWeighted / totalProbabilityWeight

 	return finalProbability

# get the probability of losing
def probOfLosing(playerPiece, enemyPiece, rankProbs):
	
	return 1 - probOfWinning(playerPiece, enemyPiece, rankProbs)
	
# get the probability of tieing
def probOfTieing(playerPiece, enemyPiece, rankProbs):

	enemyPieceID = enemyPiece.getId()
	playerPieceID = playerPiece.getId()
	playerPieceType = playerPiece.getType()
	
	# convert rank types to integers for easier looping (INDEXED AT 0)
	if playerPieceType == "B":
		playerPieceTypeInt = 9.0
	elif playerPieceType == "F":
		playerPieceTypeInt = 10.0
	elif playerPieceType == "L":
		playerPieceTypeInt = 11.0
	else:
		playerPieceTypeInt = int(playerPieceType) - 1.0 
		
	probabilityTieWeighted = 0.0
	probabilityNotTieWeighted = 0.0
	
	i = 0.0
	for key, set in iter(sorted(rankProbs.iteritems())):
		# an engineer wont tie a landmine
		if playerPieceTypeInt == 1.0 and i == 11.0:
			rankProbability = set.getAmount() / float(len(set.getPossiblePieces()))
			probabilityNotTieWeighted += rankProbability
		# ranks that can tie are the same rank, a bomb or landmine 
		elif i == playerPieceTypeInt or i == 9.0 or i == 11.0:
			rankProbability = set.getAmount() / float(len(set.getPossiblePieces()))
			probabilityTieWeighted += rankProbability
		else:
			rankProbability = set.getAmount() / float(len(set.getPossiblePieces()))
			probabilityNotTieWeighted += rankProbability
	
	# get the total probability weight
	totalProbabilityWeight = probabilityTieWeighted + probabilityNotTieWeighted
	
	# the prob of tieing is the prob of a tie divided by total weight
	finalProbability = probabilityTieWeighted / totalProbabilityWeight
	

	return finalProbability
			
# update probabilities TO-DO
def updateProbabilities(ePiece, playerPiece, outcome, movingPlayer, rankProbs):

	enemyPieceID = ePiece.getId()
	playerPieceID = playerPiece.getId()
	playerPieceType = playerPiece.getType()
	
	# convert outcome to our player's perspective
	if movingPlayer != ourPlayer:
		if outcome == "win":
			outcome = "loss"
		elif outcome == "loss":
			outcome = "win"
	
	# convert rank types to integers for easier looping
	# note: INDEXED AT 0
	if playerPieceType == "B":
		playerPieceTypeInt = 9.0
	elif playerPieceType == "F":
		playerPieceTypeInt = 10.0
	elif playerPieceType == "L":
		playerPieceTypeInt = 11.0
	else:
		playerPieceTypeInt = float(playerPieceType) - 1.0 
	
	if outcome == "tie":
		# if tie, enemy piece is either of same rank or a bomb or landmine
		for key, set in rankProbs.iteritems():
			if key != "L" and key != "B" and key != playerPieceType and \
			ePiece in set.getPossiblePieces():
		 		set.removePossiblePiece(ePiece)
	elif outcome == "win":
		# remove enemy from all ranks higher than our rank and remove L/B/F
		i = 0.0
		for key, set in iter(sorted(rankProbs.iteritems())):
			if i >= playerPieceTypeInt:
				# if our piece is an engineer, do not remove possibility enemy was an L
				if playerPieceTypeInt == 1.0 and i == 11.0:
					pass
				elif ePiece in set.getPossiblePieces():
					set.removePossiblePiece(ePiece)
			i += 1.0
	elif outcome == "loss":
		# remove enemy from all ranks below our rank and remove L/B/F possibility
		i = 0.0
		for key, set in iter(sorted(rankProbs.iteritems())):
			if i <= playerPieceTypeInt and ePiece in set.getPossiblePieces():
				set.removePossiblePiece(ePiece)
			elif i > 8.0 and ePiece in set.getPossiblePieces():
				set.removePossiblePiece(ePiece)
			i += 1.0
				
# remove enemy piece IDs from all rank set's possiblePiece if its 
# discovered elsewhere
def removePossibilities(enemyPiece, knownRank):

	enemyPieceID = enemyPiece.getId()
	
	for key, set in iter(sorted(rankSets.iteritems())):
		if key != knownRank:
			set.removePossiblePiece(enemyPieceID)


# put the enemy pieces on the board
def placeEnemyPieces():
	
	positions = ["A7","A8","A9","A10","A11","A12","B7","B9","B11","B12","C7",
	"C8","C10","C11","C12","D7","D9","D11","D12","E7","E8","E9","E10",
	"E11","E12"]
	
	for i, pos in enumerate(positions):
		nodes.getNode(pos).setPiece(EPiece(i))

# get the locations of all our pieces
def getPiecePositions():
	positions = []
	
	for key, node in nodes.iteritems():
		# check if a node contains a friendly piece
		if node.getPiece():
			if isinstance(node.getPiece(),FPiece): 
				positions.append(key)
			
	return positions

# makes a node string for the printboard function
def strNo(node):

	piece = node.getPiece()

	if piece is None:
		pieceStr = "-(-)"
	else:
		if isinstance(piece, FPiece):
			typ = "F"
			pieceStr = typ + "(" + piece.getType() + ")"
		else:
			typ = "E"
			pieceStr = typ + "(" + "?" + ")"
		
	if len(node.getId()) < 3:
		nodeId = node.getId()[0] + " " + node.getId()[1]
	else:
		nodeId = node.getId()

	result = "(" + nodeId + ":" + pieceStr + ")"

	return result

# prints out a pretty version of the board
def printBoard(board):

	sys.stderr.write("Board( \n")
	sys.stderr.write("     Age: " + str(board.getAge()) + "\n\n")

	nodes = board.getNodes()

	sys.stderr.write(strNo(nodes["A12"]) + " - " + strNo(nodes["B12"]) + " - "
	+ strNo(nodes["C12"]) + " - " + strNo(nodes["D12"]) + " - " 
	+ strNo(nodes["E12"]) + "\n\n")
	sys.stderr.write("    |     " + "     " + "     |    " + "     " 
	+ "     |    " + "     " + "     |    " + "     " + "     |    " + "\n\n")
	sys.stderr.write(strNo(nodes["A11"]) + " - " + strNo(nodes["B11"]) + " - "
	+ strNo(nodes["C11"]) + " - " + strNo(nodes["D11"]) + " - " 
	+ strNo(nodes["E11"]) + "\n\n")
	sys.stderr.write("    |     " + "  \  " + "     |    " + "  /  " 
	+ "     |    " + "  \  " + "     |    " + "  /  " + "     |    " + "\n\n")	
	sys.stderr.write(strNo(nodes["A10"]) + " - " + strNo(nodes["B10"]) + " - " 
	+ strNo(nodes["C10"]) + " - " + strNo(nodes["D10"]) + " - " 
	+ strNo(nodes["E10"]) + "\n\n")
	sys.stderr.write("     |    " + "  /  " + "     |    " + "  \  " 
	+ "     |    " + "  /  " + "     |    " + "  \  " + "     |    " + "\n\n")
	sys.stderr.write(strNo(nodes["A9"]) + " - " + strNo(nodes["B9"]) 
	+ " - " + strNo(nodes["C9"]) + " - " + strNo(nodes["D9"]) + " - " 
	+ strNo(nodes["E9"]) + "\n\n")
	sys.stderr.write("     |    " + "  \  " + "     |    " + "  /  " 
	+ "     |    " + "  \  " + "     |    " + "  /  " + "     |    " + "\n\n")	
	sys.stderr.write(strNo(nodes["A8"]) + " - " + strNo(nodes["B8"]) 
	+ " - " + strNo(nodes["C8"]) + " - " + strNo(nodes["D8"]) + " - " 
	+ strNo(nodes["E8"]) + "\n\n")
	sys.stderr.write("     |    " + "  /  " + "     |    " + "  \  " 
	+ "     |    " + "  /  " + "     |    " + "  \  " + "     |    " + "\n\n")
	sys.stderr.write(strNo(nodes["A7"]) + " - " + strNo(nodes["B7"]) 
	+ " - " + strNo(nodes["C7"]) + " - " + strNo(nodes["D7"]) + " - " 
	+ strNo(nodes["E7"]) + "\n\n")
	sys.stderr.write("     |    " + "     " + "     |    " + "     " 
	+ "     |    " + "     " + "     |    " + "     " + "     |    " + "\n\n")	
	sys.stderr.write(strNo(nodes["A6"]) + " - " + strNo(nodes["B6"]) 
	+ " - " + strNo(nodes["C6"]) + " - " + strNo(nodes["D6"]) + " - " 
	+ strNo(nodes["E6"]) + "\n\n")
	sys.stderr.write("     |    " + "  \  " + "     |    " + "  /  " 
	+ "     |    " + "  \  " + "     |    " + "  /  " + "     |    " + "\n\n")
	sys.stderr.write(strNo(nodes["A5"]) + " - " + strNo(nodes["B5"]) 
	+ " - " + strNo(nodes["C5"]) + " - " + strNo(nodes["D5"]) + " - " 
	+ strNo(nodes["E5"]) + "\n\n")
	sys.stderr.write("     |    " + "  /  " + "     |    " + "  \  " 
	+ "     |    " + "  /  " + "     |    " + "  \  " + "     |    " + "\n\n")	
	sys.stderr.write(strNo(nodes["A4"]) + " - " + strNo(nodes["B4"]) 
	+ " - " + strNo(nodes["C4"]) + " - " + strNo(nodes["D4"]) + " - " 
	+ strNo(nodes["E4"]) + "\n\n")
	sys.stderr.write("     |    " + "  \  " + "     |    " + "  /  " 
	+ "     |    " + "  \  " + "     |    " + "  /  " + "     |    " + "\n\n")
	sys.stderr.write(strNo(nodes["A3"]) + " - " + strNo(nodes["B3"]) 
	+ " - " + strNo(nodes["C3"]) + " - " + strNo(nodes["D3"]) + " - " 
	+ strNo(nodes["E3"]) + "\n\n")
	sys.stderr.write("     |    " + "  /  " + "     |    " + "  \  " 
	+ "     |    " + "  /  " + "     |    " + "  \  " + "     |    " + "\n\n")	
	sys.stderr.write(strNo(nodes["A2"]) + " - " + strNo(nodes["B2"]) 
	+ " - " + strNo(nodes["C2"]) + " - " + strNo(nodes["D2"]) + " - " 
	+ strNo(nodes["E2"]) + "\n\n")
	sys.stderr.write("     |    " + "     " + "     |    " + "     " 
	+ "     |    " + "     " + "     |    " + "     " + "     |    " + "\n\n")
	sys.stderr.write(strNo(nodes["A1"]) + " - " + strNo(nodes["B1"]) 
	+ " - " + strNo(nodes["C1"]) + " - " + strNo(nodes["D1"]) + " - " 
	+ strNo(nodes["E1"]) + "\n\n")

	sys.stderr.write(")\n")

# determine if a move is valid (for now means we arn't moving onto 
# a space occupied by our own piece), and its a move forward, 
# and we aren't attacking a camp.
def isMoveValid(move, currentPos):
	if nodes.getNode(move).getPiece():
		# check if piece is friendly or enemy
		if isinstance(nodes.getNode(move).getPiece(),FPiece):
			return False
		#check that we aren't trying to attack piece on a camp
		elif isinstance(nodes.getNode(move).getPiece(),EPiece) and \
		(nodes.getNode(move).getType() == "camp"):
			return False
		else:
			return True
	
	else:
		return True
	
# determines move value based on moving forward
# and if we are attacking an enemy piece.	
def moveValue(move, pos):
	global lastMove
	value = 1
	if int(move[1]) > int(pos[1]):
		value += int(pos[1])
	else:
		value = 0
	if nodes.getNode(move).getPiece():
		value += 1
	if move == lastMove:
		value = 0
	return value
		        
def main():
	
	global TOTAL_BOARD_PIECES
	global ALGORITHM_DEPTH
	global nodes
	global ourPlayer
	global rank1
	global rank2
	global rank3
	global rank4
	global rank5
	global rank6
	global rank7
	global rank8
	global rank9
	global rankL
	global rankB
	global rankF
	global rankSets
	
	# parse command line options
	args = sys.argv[1:]
	
	# check for invalid syntax, pass only the arguments (not the file name)
	syntaxChecker(args)
	
	# convert the time argument to a float of seconds
	timeLimit = getTimeLimit(args[3])
	
	# create a CFG of the initial board configuration
	initialConfig = jsonToCFG()
	
	# which player are we
	ourPlayer = int(args[1])

	nodeD = {}

	#A nodes	
	nodeD["A1"] = (Node("A1","standard", None, [Connection("B1", "standard"),
		Connection("A2", "standard")]))
	nodeD["A2"] = (Node("A2","standard", None, [Connection("A1", "standard"),
		Connection("B2", "rail"),
		Connection("B3","standard"),
		Connection("A3","rail")]))
	nodeD["A3"] = (Node("A3","standard", None, [Connection("A2", "rail"),
		Connection("B3", "standard"),
		Connection("A4","rail")]))
	nodeD["A4"] = (Node("A4","standard", None, [Connection("A3", "rail"),
		Connection("B3", "standard"),
		Connection("B4","standard"),
		Connection("B5","standard"),
		Connection("A5","rail")]))
	nodeD["A5"] = (Node("A5","standard", None, [Connection("A4", "rail"),
		Connection("B5", "standard"),
		Connection("A6","rail")]))
	nodeD["A6"] = (Node("A6","standard", None, [Connection("A5", "rail"),
		Connection("B5", "standard"),
		Connection("B6","rail"),
		Connection("A7","rail")]))
	nodeD["A7"] = (Node("A7","standard", None, [Connection("A6", "rail"),
		Connection("B7", "rail"),
		Connection("B8","standard"),
		Connection("A8","rail")]))
	nodeD["A8"] = (Node("A8","standard", None, [Connection("A7", "rail"),
		Connection("B8", "standard"),
		Connection("A9","rail")]))
	nodeD["A9"] = (Node("A9","standard", None, [Connection("A8", "rail"),
		Connection("B8", "standard"),
		Connection("B9","standard"),
		Connection("B10","standard"),
		Connection("A10","rail")]))
	nodeD["A10"] = (Node("A10","standard", None, [Connection("A9", "rail"),
		Connection("B10", "standard"),
		Connection("A11","rail")]))
	nodeD["A11"] = (Node("A11","standard", None, [Connection("A10", "rail"),
		Connection("B10","standard"),
		Connection("B11","rail"),
		Connection("A12","standard")]))
	nodeD["A12"] = (Node("A12","standard", None, [Connection("A11", "standard"),
		Connection("B12","standard")]))
			
	#B nodes
	nodeD["B1"] = (Node("B1","HQ", None, [Connection("C1", "standard"),
		Connection("B2", "standard"),
		Connection("A1", "standard")]))
	nodeD["B2"] = (Node("B2","standard", None, [Connection("B1", "standard"),
		Connection("C2", "rail"),
		Connection("B3","standard"),
		Connection("A2","rail")]))
	nodeD["B3"] = (Node("B3","camp", None, [Connection("B2", "standard"),
		Connection("C2", "standard"),
		Connection("C3","standard"),
		Connection("C4", "standard"),
		Connection("B4", "standard"),
		Connection("A4","standard"),
		Connection("A3","standard"),
		Connection("A2","standard")]))
	nodeD["B4"] = (Node("B4","standard", None, [Connection("B3", "standard"),
		Connection("C4", "standard"),
		Connection("B5","standard"),
		Connection("A4","standard")]))
	nodeD["B5"] = (Node("B5","camp", None, [Connection("B4", "standard"),
		Connection("C4", "standard"),
		Connection("C5","standard"),
		Connection("C6", "standard"),
		Connection("B6", "standard"),
		Connection("A6","standard"),
		Connection("A5", "standard"),
		Connection("A4","standard")]))
	nodeD["B6"] = (Node("B6","standard", None, [Connection("B5", "rail"),
		Connection("C6", "rail"),
		Connection("A6","rail")]))
	nodeD["B7"] = (Node("B7","standard", None, [Connection("C7", "rail"),
		Connection("B8", "standard"),
		Connection("A7","rail")]))
	nodeD["B8"] = (Node("B8","camp", None, [Connection("B7", "standard"),
		Connection("C7", "standard"),
		Connection("C8","standard"),
		Connection("C9", "standard"),
		Connection("B9", "standard"),
		Connection("A9","standard"),
		Connection("A8", "standard"),
		Connection("A7", "standard")]))
	nodeD["B9"] = (Node("B9","standard", None, [Connection("B8", "standard"),
		Connection("C9", "standard"),
		Connection("B10","standard"),
		Connection("A9","standard")]))
	nodeD["B10"] = (Node("B10","camp", None, [Connection("B9", "standard"),
		Connection("C9", "standard"),
		Connection("C10","standard"),
		Connection("C11", "standard"),
		Connection("B11", "standard"),
		Connection("A11","standard"),
		Connection("A10", "standard"),
		Connection("A9", "standard")]))
	nodeD["B11"] = (Node("B11","standard", None, [Connection("B10", "standard"),
		Connection("C11","rail"),
		Connection("B12","standard"),
		Connection("A11","rail")]))
	nodeD["B12"] = (Node("B12","HQ", None, [Connection("B11", "standard"),
		Connection("C12","standard"),
		Connection("A12","standard")]))
		
	#C nodes
	nodeD["C1"] = (Node("C1","standard", None, [Connection("B1", "standard"),
		Connection("C2", "standard"),
		Connection("D1", "standard")]))
	nodeD["C2"] = (Node("C2","standard", None, [Connection("C1", "standard"),
		Connection("D2", "rail"),
		Connection("D3","standard"),
		Connection("C3","standard"),
		Connection("B3","standard"),
		Connection("B2","rail")]))
	nodeD["C3"] = (Node("C3","standard", None, [Connection("C2", "standard"),
		Connection("D3", "standard"),
		Connection("C4","standard"),
		Connection("B3", "standard")]))
	nodeD["C4"] = (Node("C4","camp", None, [Connection("C3", "standard"),
		Connection("D3", "standard"),
		Connection("D4","standard"),
		Connection("D5","standard"),
		Connection("C5", "standard"),
		Connection("B5", "standard"),
		Connection("B4","standard"),
		Connection("B3","standard")]))
	nodeD["C5"] = (Node("C5","standard", None, [Connection("C4", "standard"),
		Connection("D5", "standard"),
		Connection("C6","standard"),
		Connection("B5", "standard")]))
	nodeD["C6"] = (Node("C6","standard", None, [Connection("C5", "standard"),
		Connection("D5", "standard"),
		Connection("D6","rail"),
		Connection("C7", "rail"),
		Connection("B6", "rail"),
		Connection("B5","standard")]))
	nodeD["C7"] = (Node("C7","standard", None, [Connection("C6", "rail"),
		Connection("D7", "rail"),
		Connection("D8","standard"),
		Connection("C8","standard"),
		Connection("B8","standard"),
		Connection("B7","standard")]))
	nodeD["C8"] = (Node("C8","standard", None, [Connection("C7", "standard"),
		Connection("D8", "standard"),
		Connection("C9","standard"),
		Connection("C8", "standard")]))
	nodeD["C9"] = (Node("C9","camp", None, [Connection("C8", "standard"),
		Connection("D8", "standard"),
		Connection("D9","standard"),
		Connection("D10","standard"),
		Connection("C10", "standard"),
		Connection("B10", "standard"),
		Connection("B9","standard"),
		Connection("B8","standard")]))
	nodeD["C10"] = (Node("C10","standard", None, [Connection("C9", "standard"),
		Connection("D10", "standard"),
		Connection("C11","standard"),
		Connection("B10", "standard")]))
	nodeD["C11"] = (Node("C11","standard", None, [Connection("C10", "standard"),
		Connection("D10","standard"),
		Connection("D11","rail"),
		Connection("C12","standard"),
		Connection("B11","rail"),
		Connection("B10","standard")]))
	nodeD["C12"] = (Node("C12","standard", None, [Connection("C11", "standard"),
		Connection("D12","standard"),
		Connection("B12","standard")]))

	#D nodes
	nodeD["D1"] = (Node("D1","HQ", None, [Connection("E1", "standard"),
		Connection("D2", "standard"),
		Connection("C1", "standard")]))
	nodeD["D2"] = (Node("D2","standard", None, [Connection("D1", "standard"),
		Connection("E2", "rail"),
		Connection("D3","standard"),
		Connection("C2","rail")]))
	nodeD["D3"] = (Node("D3","camp", None, [Connection("D2", "standard"),
		Connection("E2", "standard"),
		Connection("E3","standard"),
		Connection("E4", "standard"),
		Connection("D4", "standard"),
		Connection("C4","standard"),
		Connection("C3","standard"),
		Connection("C2","standard")]))
	nodeD["D4"] = (Node("D4","standard", None, [Connection("D3", "standard"),
		Connection("E4", "standard"),
		Connection("D5","standard"),
		Connection("C4","standard")]))
	nodeD["D5"] = (Node("D5","camp", None, [Connection("D4", "standard"),
		Connection("E4", "standard"),
		Connection("E5","standard"),
		Connection("E6", "standard"),
		Connection("D6", "standard"),
		Connection("C6","standard"),
		Connection("C5", "standard"),
		Connection("C4","standard")]))
	nodeD["D6"] = (Node("D6","standard", None, [Connection("D5", "rail"),
		Connection("E6", "rail"),
		Connection("C6","rail")]))
	nodeD["D7"] = (Node("D7","standard", None, [Connection("E7", "rail"),
		Connection("D8", "standard"),
		Connection("C7","rail")]))
	nodeD["D8"] = (Node("D8","camp", None, [Connection("D7", "standard"),
		Connection("E7", "standard"),
		Connection("E8","standard"),
		Connection("E9", "standard"),
		Connection("D9", "standard"),
		Connection("C9","standard"),
		Connection("C8", "standard"),
		Connection("C7", "standard")]))
	nodeD["D9"] = (Node("D9","standard", None, [Connection("D8", "standard"),
		Connection("E9", "standard"),
		Connection("D10","standard"),
		Connection("C9","standard")]))
	nodeD["D10"] = (Node("D10","camp", None, [Connection("D9", "standard"),
		Connection("E9", "standard"),
		Connection("E10","standard"),
		Connection("E11", "standard"),
		Connection("D11", "standard"),
		Connection("C11","standard"),
		Connection("C10", "standard"),
		Connection("C9", "standard")]))
	nodeD["D11"] = (Node("D11","standard", None, [Connection("D10", "standard"),
		Connection("E11","rail"),
		Connection("D12","standard"),
		Connection("C11","rail")]))
	nodeD["D12"] = (Node("D12","HQ", None, [Connection("D11", "standard"),
		Connection("E12","standard"),
		Connection("C12","standard")]))

	#E nodes	
	nodeD["E1"] = (Node("E1","standard", None, [Connection("D1", "standard"),
		Connection("E2", "standard")]))
	nodeD["E2"] = (Node("E2","standard", None, [Connection("E1", "standard"),
		Connection("E3", "rail"),
		Connection("D3","standard"),
		Connection("D2","rail")]))
	nodeD["E3"] = (Node("E3","standard", None, [Connection("E2", "rail"),
		Connection("D3", "standard"),
		Connection("E4","rail")]))
	nodeD["E4"] = (Node("E4","standard", None, [Connection("E3", "rail"),
		Connection("E5", "rail"),
		Connection("D5","standard"),
		Connection("D4","standard"),
		Connection("D3","standard")]))
	nodeD["E5"] = (Node("E5","standard", None, [Connection("E4", "rail"),
		Connection("D5", "standard"),
		Connection("E6","rail")]))
	nodeD["E6"] = (Node("E6","standard", None, [Connection("E5", "rail"),
		Connection("D5", "standard"),
		Connection("D6","rail"),
		Connection("E7","rail")]))
	nodeD["E7"] = (Node("E7","standard", None, [Connection("E6", "rail"),
		Connection("D7", "rail"),
		Connection("D8","standard"),
		Connection("E8","rail")]))
	nodeD["E8"] = (Node("E8","standard", None, [Connection("E7", "rail"),
		Connection("D8", "standard"),
		Connection("E9","rail")]))
	nodeD["E9"] = (Node("E9","standard", None, [Connection("E8", "rail"),
		Connection("D8", "standard"),
		Connection("D9","standard"),
		Connection("D10","standard"),
		Connection("E10","rail")]))
	nodeD["E10"] = (Node("E10","standard", None, [Connection("E9", "rail"),
		Connection("D10", "standard"),
		Connection("E11","rail")]))
	nodeD["E11"] = (Node("E11","standard", None, [Connection("E10", "rail"),
		Connection("D10","standard"),
		Connection("D11","rail"),
		Connection("E12","standard")]))
	nodeD["E12"] = (Node("E12","standard", None, [Connection("E11", "standard"),
		Connection("D12","standard")]))
	
	nodes.setNodes(nodeD)

	# open our json that has our initial configuration
	initConfig = open("initConfig.json")
	initConfigArray = json.load(initConfig)

	# place the pieces from the json configuration into our nodes
	i = 0
	for piece in initConfigArray:
		injectPiece(piece, i)
		i += 1

	initConfig.close()
	
	# initialize our probability metrics and rank sets
	createRankSets()

	# set up the enemy pieces on the board
	placeEnemyPieces()

	# send the referee our initial configuration
	sys.stdout.write(initialConfig)
	sys.stdout.flush()
		
	# if it is our turn first, send the referee our first move
	if ourPlayer == 1:
		sys.stdout.write("( A6 A7 )")
		sys.stdout.flush()
		
	# track how many moves in a row are being made before the time limit
	consecutiveTimesAhead = 0
	
	while(True):
	
		# get the input from the ref
		message = raw_input()

		# start capturing the time duration of our move (not needed for prototype)
		startTime = time.time() 
	
		if (message == "Invalid Board Setup"):
			sys.stderr.write("Board was not correctly set up. Exiting game.\n")
			sys.exit(0)
		
		# match just the first 18 characters which are always the same
		elif (message[:18] == "Invalid Board Move"):
			sys.stderr.write("We sent an invalid move. Exiting game.\n")
			sys.exit(0)
			
		elif ("Victory" in message):
			if ("1" in message):
				sys.stderr.write("Player 1 is the victor. Exiting game.\n")
				sys.exit(0)
			elif ("2" in message):
				sys.stderr.write("Player 2 is the victor. Exiting game.\n")
				sys.exit(0)
			else:
				sys.stderr.write("There was no victor. Exiting game.\n")
				sys.exit(0)
		
		elif (message[0] == "F"):
			# a field marshall has been captured and the flag is revealed
			# not needed for the prototype
			pass
		
		else:
			
			# make sure the referee's message is properly formatted
			if (message.count(' ') != 3):
				sys.stderr.write("Error: The referee provided an invalid message.\n")
				sys.exit(0)
			
			# parse the referee's input
			messageArgs = message.split(' ')
			movingFrom = messageArgs[0]
			movingTo = messageArgs[1]
			movingPlayer = messageArgs[2]
			moveType = messageArgs[3]
			
			# update our board (currently ignoring opponent's pieces and railroads)
			updateBoard(movingFrom, movingTo, movingPlayer, moveType)
				
			# we don't want to send our move, if the referee is simply reporting 
			# what we have done.
			if (ourPlayer == int(movingPlayer)):
				sys.stdout.flush()
				continue
						
			# grow algorithm depth as there is less to be calculated
			if (consecutiveTimesAhead > 5):
				ALGORITHM_DEPTH = 3
						
			# select the next move
			nextMove = getNextMove()
			
			# send the ref the move
			sys.stdout.write(nextMove)
			
			# check to make sure we haven't gone past our time limit 
			# (not needed for prototype)
			timeLeft = timeLimit - (time.time() - startTime)
			
			# our algorithm requires at least .95 seconds to run a depth of 3
			if (timeLeft > .95):
				consecutiveTimesAhead += 1
			else:
				consecutiveTimesAhead = 0

		sys.stdout.flush()
		
if __name__ == "__main__":
    main()
